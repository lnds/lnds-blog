<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Close to the Edge, down by the river | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/posts/2017/close-to-the-edge-down-to-the-river/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="Close to the Edge, down by the river">
  <meta property="og:description" content="La historia del rock está llena de anécdotas que reflejan el choque de egos entre artistas, como cuando Jimmy Hendrix le roba el acto de quemar la guitarra a Pete Townsend, en el Festival de Monterrey de 1967. Hay otra involucra a Yes y Deep Purple.
La historia transcurre en la décima edición del National Jazz &amp; Blues Festival en Plumpton, en Inglaterra, en agosto de 1970. Los organizadores habían decidido que Deep Purple cerrara el espectáculo, algo que molestó a Yes, quienes querían clausurar el evento. Así que la banda liderada por Jon Anderson decidió retrasar su llegada, obligando a los organizadores a solicitar a Deep Purple que ejecutaran su show antes.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-07-17T08:25:11-03:00">
    <meta property="article:modified_time" content="2017-07-17T08:25:11-03:00">
    <meta property="article:tag" content="Desafios">
    <meta property="article:tag" content="Lenguajes Nuevos">
    <meta property="article:tag" content="Lenguajes">
    <meta property="article:tag" content="Lenguajes De Programación">
    <meta property="article:tag" content="Programación">
    <meta property="article:tag" content="Rock">
    <meta property="og:image" content="http://localhost:1313/posts/2017/close-to-the-edge-down-to-the-river/featured.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/posts/2017/close-to-the-edge-down-to-the-river/featured.png">
  <meta name="twitter:title" content="Close to the Edge, down by the river">
  <meta name="twitter:description" content="La historia del rock está llena de anécdotas que reflejan el choque de egos entre artistas, como cuando Jimmy Hendrix le roba el acto de quemar la guitarra a Pete Townsend, en el Festival de Monterrey de 1967. Hay otra involucra a Yes y Deep Purple.
La historia transcurre en la décima edición del National Jazz &amp; Blues Festival en Plumpton, en Inglaterra, en agosto de 1970. Los organizadores habían decidido que Deep Purple cerrara el espectáculo, algo que molestó a Yes, quienes querían clausurar el evento. Así que la banda liderada por Jon Anderson decidió retrasar su llegada, obligando a los organizadores a solicitar a Deep Purple que ejecutaran su show antes.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Close to the Edge, down by the river</h1><time class="dim" datetime="2017-07-17T08:25:11-03:00">July 17, 2017</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/desafios/">#desafios</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes-nuevos/">#lenguajes nuevos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes/">#lenguajes</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes-de-programaci%C3%B3n/">#lenguajes de programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n/">#programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/rock/">#rock</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/scala/">#scala</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n-funcional/">#programación funcional</a>
      </div></ol></div>
  <section class="page-section"><p>La historia del rock está llena de anécdotas que reflejan el choque de
egos entre artistas, como cuando Jimmy Hendrix le roba el acto de quemar
la guitarra a Pete Townsend, en el Festival de Monterrey de 1967. Hay
otra involucra a Yes y Deep Purple.</p>
<p>La historia transcurre en la décima edición del National Jazz &amp; Blues
Festival en Plumpton, en Inglaterra, en agosto de 1970. Los
organizadores habían decidido que Deep Purple cerrara el espectáculo,
algo que molestó a Yes, quienes querían clausurar el evento. Así que la
banda liderada por Jon Anderson decidió retrasar su llegada, obligando a
los organizadores a solicitar a Deep Purple que ejecutaran su show
antes.</p>
<p>Pero Ritchie Blackmore planeó una venganza notable. Después de
interpretar casi íntegramente su álbum <a href="https://en.wikipedia.org/wiki/Deep_Purple_in_Rock">&ldquo;In Rock&rdquo;</a>,
seleccionaron para el cierre de su espectáculo interpretar el clásico
<a href="https://www.youtube.com/watch?v=O4irXQhgMqg">Paint In Black</a> de los
Rolling Stones. Durante la ejecución del tema Blackmore ordenó a sus
&ldquo;roadies&rdquo; que vaciaran combustible sobre los equipos, luego encendió
un fósforo y lo arrojo al suelo, y siguió tocando su guitarra mientras
empezaba un incendio sobre el escenario.</p>
<p>Yes logró tocar último, pero los asistentes quedaron impresionados al
punto que todos comentaban la espectacular puesta en escena de Deep
Purple. Así que Ritchie Blackmore tuvo su dulce venganza, y consiguió
que Deep Purple acaparara los comentarios de los asistentes a esa
jornada relegando a Yes al segundo plano.</p>
<p><img src="https://d2dspjyoh5c79p.cloudfront.net/65f51b37-6a96-11e7-976c-0d1ee2977bbe-aa9f18b7" alt=""></p>
<p>Yes es una banda con una historia compleja, con diversas formaciones,
agrupaciones, reagrupaciones, incluso en un momento hubo dos Yes
operando en paralelo.</p>
<p>Esto se refleja también en su música, que alcanzó los máximos puntos de
complejidad interpretativa con la incorporación del tecladista Rick
Wakeman. Yes ha reunido a grandes músicos, y servido de inspiración a
diversas bandas del rock progresivo.</p>
<h1 id="el-cuarto-desafío">El Cuarto Desafío</h1>
<p>Este artículo no es sobre Yes o rock progresivo, este post es parte de
<a href="/blog/lnds/2016/01/09/esos-raros-lenguajes-nuevos">la serie sobre nueve lenguajes en nueve desafíos de programación</a>,
y en particular aborda el cuarto desafío de esta serie, compresión
usando la codificación de Huffman.</p>
<p>Cuando decidí escribir este cuarto desafío pensé que escribiría un
artículo por cada una de las soluciones en cada uno de los lenguajes.
Pero también decidí asociar un grupo o artista de rock o pop a cada
lenguaje.</p>
<p>Esta vez es el turno de Scala. </p>
<p>Yes es una banda compleja, del mismo modo que Scala es un lenguaje
complejo.</p>
<p><img src="https://d2dspjyoh5c79p.cloudfront.net/86ff34a8-6a96-11e7-976c-0d1ee2977bbe-aa9f18b7" alt=""></p>
<p>En <a href="/blog/lnds/2017/06/10/pour-some-syntactic-sugar-on-me">el primer post de esta serie</a>
asocié, accidentalmente en realidad, a Def Leppard con Kotlin. Esta vez
consulté a mi amigo <a href="https://twitter.com/utaladriz">Ubaldo Taladriz</a>,
quien lleva más horas de vuelo que yo usando Scala. Le pedí su opinión
sobre qué banda le parecía más adecuada para reflejar a este lenguaje. Y
llegamos a la conclusión de que tenía que ser algo que reflejara la
complejidad, pero además fuera un grupo de gran calidad, con buenas
canciones.  </p>
<p>Las composiciones de Yes tienen esa componente, sobretodo en álbumes
como Fragile, o Close to the Edge. [Pero Yes también ha seguido
derroteros más populares, como en los álbumes de 90125, o Big
Generator.</p>
<p>El registro de Yes va desde clásicos como Close to the Edge, Starship
Trooper, RoundAbout, hasta hits como Owner of a Lonely Heart.</p>
<p>En Scala podemos escribir código muy simple y cercano a Java. Pero a
diferencia de Java, es más difícil escapar del paradigma orientado al
objeto en Scala.</p>
<h2 id="el-desafío-huffman">El desafío Huffman</h2>
<p>Recordemos que en este desafío estoy implementando la compresión de
archivos usando la codificación de Huffman. Pueden leer la explicación
de este desafío en <a href="/blog/lnds/2017/06/10/pour-some-syntactic-sugar-on-me">mi anterior artículo</a>.</p>
<p>Mi primera solución en Scala es una simple traducción de la versión en
Kotlin <a href="/blog/lnds/2017/6/10/pour-some-syntactic-sugar-on-me">descrita anteriormente</a>.</p>
<p>Por supuesto, hacer esto es un tanto decepcionante. Por ejemplo,
consideren este fragmento de código:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#66d9ef">import</span> scala.util.control.Breaks._
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">....</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> extract<span style="color:#f92672">()</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffTree</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>empty<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayIndexOutOfBoundsException</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> min <span style="color:#66d9ef">=</span> heap<span style="color:#f92672">(</span><span style="color:#ae81ff">1</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        heap<span style="color:#f92672">(</span><span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">=</span> heap<span style="color:#f92672">(</span>last<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        last <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> j <span style="color:#66d9ef">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        breakable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> j <span style="color:#f92672">&lt;=</span> last<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> k <span style="color:#66d9ef">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> j
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> last <span style="color:#f92672">&amp;&amp;</span> heap<span style="color:#f92672">(</span>k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">).</span>frequency <span style="color:#f92672">&lt;</span> heap<span style="color:#f92672">(</span>k<span style="color:#f92672">).</span>frequency<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              k <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>heap<span style="color:#f92672">(</span>j<span style="color:#f92672">).</span>frequency <span style="color:#f92672">&lt;</span> heap<span style="color:#f92672">(</span>k<span style="color:#f92672">).</span>frequency<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              break
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> tmp <span style="color:#66d9ef">=</span> heap<span style="color:#f92672">(</span>j<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            heap<span style="color:#f92672">(</span>j<span style="color:#f92672">)</span> <span style="color:#66d9ef">=</span> heap<span style="color:#f92672">(</span>k<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            heap<span style="color:#f92672">(</span>k<span style="color:#f92672">)</span> <span style="color:#66d9ef">=</span> tmp
</span></span><span style="display:flex;"><span>            j <span style="color:#66d9ef">=</span> k
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        min
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>En Scala no existe la primitiva <strong>break</strong>, que existe en Kotlin para
interrumpir un loop. </p>
<p>En Scala, esto se simula en el package scala.util.control.Breaks, que
define un DSL para esto. </p>
<p>Los diseñadores de Scala decidieron que este tipo de estructuras
introduce más problemas, y tienen razón en mi opinión. A veces esta
interrupción de un loop hace que razonar sobre el comportamiento de una
función sea más difícil.</p>
<p>El código anterior es parte de la implementación de un Heap, como
estructura de datos.</p>
<p>La primera solución, es decir, la traducción del código Kotlin está
disponible en Github en el siguiente repositorio:
 <a href="https://github.com/lnds/9d9l/tree/master/desafio4/scala1">https://github.com/lnds/9d9l/tree/master/desafio4/scala1</a></p>
<p>No es muy interesante en el sentido de que no destaca muchas de las
características de Scala.</p>
<p>Así que escribí una segunda solución, en la que usé un estilo más
funcional para una parte crucial del código.</p>
<p>En vez de implementar un Heap, hice una interpretación más directa del
algoritmo:</p>
<ol>
<li>Por cada tupla (carácter, frecuencia) armamos un nodo hoja y los
dejamos en una lista ordenada por el valor frecuencia en forma
ascendente.</li>
<li>Tomamos los dos primeros elementos de la lista los combinamos en un
nodo interno, donde la frecuencia del nodo es la suma de las
frecuencias de las dos hojas que contiene. Insertamos este nodo en
la lista, manteniendo el orden.</li>
<li>Repetimos hasta que sólo quede un árbol en la lista.</li>
</ol>
<p>Para esto nuestro modelo de datos es el siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HuffTree</span><span style="color:#f92672">(</span><span style="color:#66d9ef">val</span> frequency<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HuffLeaf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">val</span> frequency<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span><span style="color:#f92672">,</span>  symbol<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Char</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">HuffTree</span><span style="color:#f92672">(</span>frequency <span style="color:#66d9ef">=</span> frequency<span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HuffNode</span><span style="color:#f92672">(</span>left<span style="color:#66d9ef">:</span><span style="color:#66d9ef">HuffTree</span><span style="color:#f92672">,</span> right<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffTree</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">HuffTree</span><span style="color:#f92672">(</span>left<span style="color:#f92672">.</span>frequency<span style="color:#f92672">+</span>right<span style="color:#f92672">.</span>frequency<span style="color:#f92672">)</span> 
</span></span></code></pre></div><p>Creamos una clase abstracta y dos case clases, una para Hoja y otra para
Nodo.</p>
<p>Las <em>&ldquo;case classes&rdquo;</em> son ideales para trabajar con estructuras de
datos inmutables, cómo las  listas. De este modo la primera parte del
algoritmo queda así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>     <span style="color:#66d9ef">val</span> leaves <span style="color:#66d9ef">=</span> freqs
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>map <span style="color:#f92672">{</span> <span style="color:#66d9ef">case</span> <span style="color:#f92672">(</span>sym<span style="color:#f92672">,</span> freq<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> <span style="color:#a6e22e">HuffLeaf</span><span style="color:#f92672">(</span>freq<span style="color:#f92672">,</span> sym<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>sortWith<span style="color:#f92672">((</span>l1<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">,</span> l2<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> l1<span style="color:#f92672">.</span>frequency <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">.</span>frequency<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>freqs es una lista de pares (carácter, frequencia), que se construye al
leer el archivo. Al estar en una lista puedo <em>mapear</em> cada par
insertándolos en un nodo hoja. Luego se ordena la lista con el método
sortWith.</p>
<p>Esto nos permite eliminar la necesidad de crear una estructura de datos
como el Heap, de la solución inicial.</p>
<p>Ahora bien, ¿cómo implementamos los pasos 2 y 3 repetidamente?</p>
<p>La solución funcional a esto es muy elegante. </p>
<p>Lo primero que haremos es lo siguiente: c[rearemos una función que nos
indique si la lista, que contiene todos los nodos (o árboles) sólo
contiene un elemento:]{style=&ldquo;letter-spacing: 0.01rem;&rdquo;}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> singleton<span style="color:#f92672">(</span>trees<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[</span><span style="color:#66d9ef">HuffTree</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Boolean</span> <span style="color:#f92672">=</span> trees<span style="color:#f92672">.</span>length <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Esta función recibe una lista de árboles y retorna verdadero sólo si la
lista contiene un sólo elemento. Recordemos que iniciamos con una lista
de hojas (leaves) obtenida anteriormente.</p>
<p>Lo otro que haremos es una función de <em>combinación</em>, esta implementa en
esencia el paso 2 de nuestro algoritmo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>     <span style="color:#66d9ef">def</span> combine<span style="color:#f92672">(</span>trees<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[</span><span style="color:#66d9ef">HuffTree</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[</span><span style="color:#66d9ef">HuffTree</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span>
</span></span><span style="display:flex;"><span>        trees <span style="color:#66d9ef">match</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> left <span style="color:#66d9ef">:</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">right</span> <span style="color:#66d9ef">::</span> <span style="color:#66d9ef">tail</span> <span style="color:#f92672">=&gt;</span> 
</span></span><span style="display:flex;"><span>           <span style="color:#f92672">(</span><span style="color:#a6e22e">HuffNode</span><span style="color:#f92672">(</span>left<span style="color:#f92672">,</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">:</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">tail</span><span style="color:#f92672">).</span>sortWith<span style="color:#f92672">((</span>l1<span style="color:#f92672">,</span>l2<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> l1<span style="color:#f92672">.</span>frequency <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">.</span>frequency<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">=&gt;</span> trees
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>La función combine recibe una lista, si la lista tiene al menos dos
elementos, tomamos los dos primeros elementos para crear un nodo
interno:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> left <span style="color:#66d9ef">:</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">right</span> <span style="color:#66d9ef">::</span> <span style="color:#66d9ef">tail</span> <span style="color:#f92672">=&gt;</span>  <span style="color:#f92672">(</span><span style="color:#a6e22e">HuffNode</span><span style="color:#f92672">(</span>left<span style="color:#f92672">,</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">:</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">tail</span><span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Este fragmento de código es un <em>&ldquo;pattern matching&rdquo;,</em> en este caso el
patrón es **left :: right :: tail.
**Este patrón corresponde a los dos primeros elementos de la lista y
tail representa el resto de los elementos. </p>
<p>Lo que viene después de =&gt; es una transformación, en este caso
convertimos el patrón left::right::tail en HuffNode(left, right)::tail,
es decir, reemplazamos los dos primeros elementos por un nodo interno
que contiene a estos elementos como hijos. Y a este nodo le concatenamos
el resto de la lista (tail).</p>
<p>Por supuesto, esto no es suficiente, hay que mantener ordenada la lista
resultante, y eso se logra agregando la llamada a sortWith.</p>
<p>Entonces, la función combine lo que hace es ejecutar el paso dos de
nuestro algoritmo, tomar dos elementos iniciales de una lista de nodos
(ordenada en orden ascendente de frecuencias) y generar una nueva lista
ordenada, en que los dos primeros nodos han sido reemplazados por un
nodo interno que los contiene.</p>
<p>Ahora falta la repetición, y para eso usamos  la función until:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#a6e22e">@tailrec</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> until<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>singleton<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Boolean</span><span style="color:#f92672">,</span> combine<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=&gt;</span> A<span style="color:#f92672">)(</span>data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>singleton<span style="color:#f92672">(</span>data<span style="color:#f92672">))</span> data <span style="color:#66d9ef">else</span> until<span style="color:#f92672">(</span>singleton<span style="color:#f92672">,</span> combine<span style="color:#f92672">)(</span>combine<span style="color:#f92672">(</span>data<span style="color:#f92672">))</span>
</span></span></code></pre></div><p>Esta es una función recursiva y genérica. Recibe una tupla consistente
en la función condicional que nos permite establecer la condición de
término de la recursión, en este caso es singleton, Además recibe una
función de combinación. Todo esto será aplicado sobre data, que es la
estructura que recorreremos (en este caso una lista, pero puede ser
cualquier estructura de datos que soporte las operaciones singleton y
combine.</p>
<p>La anotación @tailrec indica a Scala que puede optimizar el código de
esta recursión mediante la técnica de <a href="https://en.wikipedia.org/wiki/Tail_call">tail call</a>.</p>
<p>Así que crear el árbol final a partir de la lista de hojas es tan simple
como esto:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    until<span style="color:#f92672">(</span>singleton<span style="color:#f92672">,</span> combine<span style="color:#f92672">)(</span>leaves<span style="color:#f92672">).</span>head
</span></span></code></pre></div><p>De este modo, la función que construye el árbol de Huffman es la
siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>     <span style="color:#66d9ef">def</span> build<span style="color:#f92672">(</span>freqs<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">List</span><span style="color:#f92672">[(</span><span style="color:#66d9ef">Char</span>, <span style="color:#66d9ef">Int</span><span style="color:#f92672">)])</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffTree</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> leaves <span style="color:#66d9ef">=</span> freqs
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>map <span style="color:#f92672">{</span> <span style="color:#66d9ef">case</span> <span style="color:#f92672">(</span>sym<span style="color:#f92672">,</span> freq<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> <span style="color:#a6e22e">HuffLeaf</span><span style="color:#f92672">(</span>freq<span style="color:#f92672">,</span> sym<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>sortWith<span style="color:#f92672">((</span>l1<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">,</span> l2<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> l1<span style="color:#f92672">.</span>frequency <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">.</span>frequency<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        until<span style="color:#f92672">(</span>singleton<span style="color:#f92672">,</span> combine<span style="color:#f92672">)(</span>leaves<span style="color:#f92672">).</span>head
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Por supuesto esta implementación es más lenta que las solución 1, en
este caso la elegancia de la solución tiene un costo de performance,
pero no es tan caro como pueda parecer. Al final de esta serie
evaluaremos el desempeño de las distintas soluciones.</p>
<p>Hay una otras maneras de solucionar esto usando Scala de una forma más
funcional aún, usando otras estructuras de datos propias de Scala, pero
se los dejo como ejercicio.</p>
<h2 id="close-to-the-edge">Close to the edge</h2>
<p>Scala es uno de esos lenguajes que permite acercarse a los extremos,
&ldquo;close to the edge&rdquo;, hacia un estilo más funcional, lo que permite
escribir código que tiene cierta elegancia, concisión, e incluso una
formalidad matemática mayor, que permite simplificar el razonamiento
sobre el flujo de la información durante la ejecución. </p>
<p>Con esta construcción</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    <span style="color:#a6e22e">@tailrec</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> until<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>singleton<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">Boolean</span><span style="color:#f92672">,</span> combine<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=&gt;</span> A<span style="color:#f92672">)(</span>data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>singleton<span style="color:#f92672">(</span>data<span style="color:#f92672">))</span> data <span style="color:#66d9ef">else</span> until<span style="color:#f92672">(</span>singleton<span style="color:#f92672">,</span> combine<span style="color:#f92672">)(</span>combine<span style="color:#f92672">(</span>data<span style="color:#f92672">))</span>
</span></span></code></pre></div><p>hemos creado un lenguaje de dominio específico para procesar datos.
Scala nos permite crear nuevas estructuras para operar sobre una gran
cantidad de estructuras de datos. Tenemos el poder de extender los
límites del lenguaje.</p>
<h2 id="down-by-the-river">Down by the river</h2>
<p>Usar estructuras inmutables es lo que ayuda. La programación funcional
puede ser vista como el flujo de datos a través de diversos filtros, una
corriente de información, donde cada función es un filtro, una cañería,
que transforma la data en cada paso.</p>
<p>El mejor ejemplo es el código de arriba:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>     freqs
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>map <span style="color:#f92672">{</span> <span style="color:#66d9ef">case</span> <span style="color:#f92672">(</span>sym<span style="color:#f92672">,</span> freq<span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> <span style="color:#a6e22e">HuffLeaf</span><span style="color:#f92672">(</span>freq<span style="color:#f92672">,</span> sym<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">.</span>sortWith<span style="color:#f92672">((</span>l1<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">,</span> l2<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">HuffLeaf</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">=&gt;</span> l1<span style="color:#f92672">.</span>frequency <span style="color:#f92672">&lt;</span> l2<span style="color:#f92672">.</span>frequency<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Un flujo de datos desde un arreglo de bytes para terminar en una lista
de nodos.</p>
<p>Y cuando hacemos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    until<span style="color:#f92672">(</span>singleton<span style="color:#f92672">,</span> combine<span style="color:#f92672">)(</span>leaves<span style="color:#f92672">).</span>head
</span></span></code></pre></div><p>también trabajamos con un flujo controlado de datos, un rio de
información.</p>
<p>Así que la elección de Yes para hablar de Scala resultó muy adecuada.</p>
<p>El código está disponible en <a href="https://github.com/lnds/9d9l">mi repositorio GitHub</a>
y pueden hacerme las consultas que
estimen conveniente. Recibo también pull request con mejoras y aportes.</p>
<p>Referencias:</p>
<p>Para la primera parte de esta serie lee: <a href="/blog/lnds/2017/06/10/pour-some-syntactic-sugar-on-me">Pour some syntactic sugar on me</a></p>
<p>Para entender la serie: <a href="/blog/lnds/2016/01/09/esos-raros-lenguajes-nuevos">Esos raros lenguajes nuevos</a></p>
<p>Repositorio GitHub: https://github.com/lnds/9d9l/</p>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Eduardo Díaz</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>1945 words</span>
    <span>12 - 15 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#el-desafío-huffman">El desafío Huffman</a></li>
    <li><a href="#close-to-the-edge">Close to the edge</a></li>
    <li><a href="#down-by-the-river">Down by the river</a></li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/posts/2017/close-to-the-edge-down-to-the-river/featured.png">featured.png</a></li></ul><h3>Related</h3>
    <ul><li><a href="/posts/2017/pour-some-syntactic-sugar-on-me/">Pour Some Syntactic Sugar on Me</a></li><li><a href="/posts/2016/como-obtener-el-reporte-del-clima/">Cómo obtener el reporte del clima</a></li><li><a href="/posts/2016/chubascos-de-ligera-intensidad/">Chubascos de ligera intensidad</a></li><li><a href="/posts/2016/reporte-del-clima/">Reporte del Clima</a></li><li><a href="/posts/2017/fake-it-till-you-make-it/">Fake it till you make it</a></li></ul></aside></div>
  </div>
</body>
</html>
