<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>1 de 5.000 ó 5.000 de 1 (batch y transaccional)  | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/posts/2010/1-de-5-000-o-5-000-de-1-batch-y-transaccional/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="1 de 5.000 ó 5.000 de 1 (batch y transaccional) ">
  <meta property="og:description" content="Es fácil engañarse cuando se intenta optimizar, lo que parece lógico, y hasta numéricamente plausible puede estallarnos en la cara cuando lo analizamos en detalle, especialmente cuando lo ponemos a prueba en la práctica.
Es típico que algún experto nos aconseje sobre usar determinada técnica, porque en teoría es más óptima. Los novatos tienden a aplicar estas propuestas sin cuestionarlas mucho. Los más viejos tendemos a confiar en la experiencia, y esta suele darnos la razón.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2010-04-04T08:25:11-03:00">
    <meta property="article:modified_time" content="2010-04-04T08:25:11-03:00">
    <meta property="article:tag" content="Procesos">
    <meta property="article:tag" content="Algoritmos">
    <meta property="article:tag" content="Programación">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="1 de 5.000 ó 5.000 de 1 (batch y transaccional) ">
  <meta name="twitter:description" content="Es fácil engañarse cuando se intenta optimizar, lo que parece lógico, y hasta numéricamente plausible puede estallarnos en la cara cuando lo analizamos en detalle, especialmente cuando lo ponemos a prueba en la práctica.
Es típico que algún experto nos aconseje sobre usar determinada técnica, porque en teoría es más óptima. Los novatos tienden a aplicar estas propuestas sin cuestionarlas mucho. Los más viejos tendemos a confiar en la experiencia, y esta suele darnos la razón.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>1 de 5.000 ó 5.000 de 1 (batch y transaccional) </h1><time class="dim" datetime="2010-04-04T08:25:11-03:00">April 4, 2010</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/procesos/">#procesos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/algoritmos/">#algoritmos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n/">#programación</a>
      </div></ol></div>
  <section class="page-section"><p>Es fácil engañarse cuando se intenta optimizar, lo que parece lógico, y
hasta numéricamente plausible puede estallarnos en la cara cuando
<a href="/blog/2009/08/enganos-numericos.html">lo analizamos en detalle</a>,
especialmente cuando lo ponemos a prueba en la práctica.</p>
<p>Es típico que algún experto nos aconseje sobre usar determinada técnica,
porque en teoría es más óptima. Los novatos tienden a aplicar estas
propuestas sin cuestionarlas mucho. Los más viejos tendemos a confiar en
la experiencia, y esta suele darnos la razón.</p>
<p>Es lo que le pasó a Jeff Attwood, quien en un
<a href="http://www.codinghorror.com/blog/2010/03/compiled-or-bust.html">muy brillante post</a>
demuestra que el experto no tenía razón, y que lo que la práctica le
decía tenía un fundamento, después de todo. Y el problema que explica
Attwood es interesante, porque me he topado con el mismo varias veces,
incluso recientemente.</p>
<p>La cosa es más o menos así, <a href="http://weblogs.asp.net/omarzabir/archive/2008/10/28/solving-common-problems-with-compiled-queries-in-linq-to-sql-for-high-demand-asp-net-websites.aspx">de acuerdo a un
experto</a>,
citado por Attwood</p>
<blockquote>
<p>&ldquo;SI estás construyendo aplicaciones web ASP.NET, que van a tener
miles de hits por segudo, la sobrecarga de ejecución de las consultas
Linq van a consumir demasiada CPU y harán tu sitio web lento. Hay un
costo en momento de ejecución asociado con con cada una de las
consultas Linq que escribes. Las consultas son analizadas y
convertidas a una sentencia SQL en cada hit. Esto no es hecho en
tiempo de compilación, porque no hay manera de saber que puedes enviar
en los parámetros a las consultas durante la ejecución.&rdquo;</p></blockquote>
<p>Aunque Jeff Attwood está hablando de Linq y ASP.Net, el problema puede
extrapolarse a otros ambientes, como PHP, o Java, en que tenemos
consultas (queries) que se interpretan en tiempo de ejecución.</p>
<p>El mecanismo de Linq es bien elegante, y en mi opinión, más poderoso que
otros ORM. En el caso particular que expone el autor se tiene una
consulta en Linq más o menos así</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> query = <span style="color:#66d9ef">from</span> widget <span style="color:#66d9ef">in</span> dc.Widgets
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> widget.ID == id &amp;&amp; widget.PageID == pageId
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">select</span> widget;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> widget = query.SingleOrDefault();
</span></span></code></pre></div><p>El experto afirma que estuvo analizando el problema de este tipo de
ejecuciones y descubrió que la ejecución de este tipo de sentencias hace
palidecer al tiempo que se gasta en el <em>roundtrip</em> a la base de datos!!</p>
<p>Es decir, al parecer, se gasta más tiempo analizando estas sentencias
Linq que en la ejecución del código resultante en la base de datos. Por
lo tanto, lo que hay que hacer, nos recomienda, es compilar estos
queries, antes de ejecutarlas (algo que complejiza bastante el código, y
hace de la mantención del mismo una tarea más ardua).</p>
<p>Se pueden imaginar la cara que puso Jeff Attwood cuando leyó estas
afirmaciones:</p>
<p><img src="coding-horror-official-logo-small.png" alt="coding-horror-official-logo-small.png"></p>
<p>Porque simplemente no lo podía creer. De hecho, el sitio Stack Overflow,
con sobre 1.6 millones de page views al día, tiene muchas lineas de
código que dependen de sentencias Linq como las cuestionadas por Omar Al
Zabir, el experto MVP, <a href="http://www.amazon.com/dp/0596510500?tag=wwwoazabircom-20&amp;camp=14573&amp;creative=327641&amp;linkCode=as1&amp;creativeASIN=0596510500&amp;adid=1WQZNVWKP6R3WW52QEW1&amp;">autor de libros sobre el
tema</a>.</p>
<p>Y para darle más peso a su argumento, Omar Al Zabir muestra los datos de
<a href="http://blogs.msdn.com/ricom/default.aspx">Rico Mariani</a>, un ingeniero
de Microsoft, quien condujo una serie de experimentos en que probaban el
desempeño de sentencias Linq compiladas versus las no compiladas.</p>
<p>Esta es la tabla que Al Zabir muestra, extraida del artículo con <a href="http://blogs.msdn.com/ricom/archive/2008/01/14/performance-quiz-13-linq-to-sql-compiled-query-cost-solution.aspx">los
expermientos de Rico
Mariani</a>:</p>
<p><img src="zabir_argument.png" alt="zabir_argument.png"></p>
<p><strong>Pero hay una trampita.</strong></p>
<p>Para entender porque las afirmaciones de Omar Al Zabir no cuadran con la
experiencia de Attwood, hay que entender como se hicieron las pruebas, y
así podemos ver que Al Zabir comete un grave error, generalizando una
solución, que es altamente dependiente del tipo de operación que vamos a
realizar.</p>
<p>Rico Mariani nos explica que para comparar los dos tipos de consultas el
ejecutó básicamente estos dos test:</p>
<p>Para el caso de las queries pre compiladas:</p>
<pre tabindex="0"><code>start timer
for (j=0;j\&lt;batches;j++)
    compile query

for (i=0;i\&lt;runs;i++)
    create new data context
    run query in new context

stop timer
print number of selects and time etc.
</code></pre><p>Para el caso de las consultas interpretadas (no pre compiladas):</p>
<pre tabindex="0"><code>start timer

for (j=0;j\&lt;batches;j++)
    for (i=0;i\&lt;runs;i++)
        create new data context
        run query in new context
 stop timer
 print number of selects and time etc.
</code></pre><p>Y lo que hace Rico Mariani es ir jugando con la cantidad de ejecuciones,
y el tamaño del proceso batch, lo que genera una tabla de resultados
mucho más larga, y que tiene al final de la misma unos resultados que
son ignorados por Al Zabir (no sabemos si intencionalmente). Estos
resultados ignorados por el &ldquo;experto&rdquo; son:</p>
<blockquote>
<p>Testing 2500 batches of 2 selects 5000 selects uncompiled 9165.0ms
25000 records total 545.55 selects/sec<br>
5000 selects compiled 7892.0ms 25000 records total 633.55 selects/sec<br>
Testing 5000 batches of 1 selects<br>
5000 selects uncompiled 9157.0ms 25000 records total 546.03
selects/sec</p>
<p>5000 selects compiled 10825.0ms 25000 records total 461.89 selects/sec</p></blockquote>
<p>Seguramente se han mareado a estas alturas, pero se los voy a resumir:</p>
<p>Al partir el experimento, se prueba con 1 lote de 5.000 selects. En el
caso compilado se logran 925 selects/segundo, y sin compilar 543 selects
por segundo. Ganador la versión compilada.</p>
<p>Al final del experimento, se pruena con 5.000 lotes con 1 select. En el
caso compilado se logran 461 selects/segundo y sin compilar se logran
546 selects/ segundo.</p>
<p>De hecho si graficamos el tamaño del lote versus el desempeño en
selects/segundo, queda claro lo que pasa:</p>
<p><img src="performance_comp_vs_nocomp.jpg" alt="performance_comp_vs_nocomp.jpg"></p>
<p>¿Qué siginifica esto?</p>
<p>Resulta que nos encontramos ante los dos extremos de aplicaciones
posibles, la aplicación de Attwood es una aplicación web, fuertemente
<strong>transaccional</strong>, es decir, está en el extremo de los 5.000 lotes de
tamaño 1. Por otro lado, las recomendaciones de Omar Al Zabir son útiles
cuando el tamaño del lote es grande (lotes de 5.000 o más selects). Las
recomendaciones de Al Zabir son muy útiles cuando estamos ante
aplicaciones <strong>batch</strong>, offline, no transaccionales.</p>
<p>Ese es el caso particular de las aplicaciones con las que tengo que
lidiar en mi trabajo, aplicaciones batch, con procesamiento de miles o
millones de registros, es todo lo contrario de las aplicaciones
transaccionales web. En mi caso los consejos de Al Zabir podrían tener
aplicación (si usara Linq).</p>
<p>¿Es esto aplicable a la discusión del uso de los lenguajes compilados,
versus los lenguajes interpretados? ¿O a otras aplicaciones? ¿como el
uso de un ORM, versus llamadas directas a la base de datos usando JDBC,
por ejemplo? Sospecho que sí, pero es una afirmación que, como siempre,
requiere ser demostrada, y para eso hay que mostrar el código.</p>
<p>Referencias:</p>
<ul>
<li><a href="http://www.codinghorror.com/blog/2010/03/compiled-or-bust.html">Compiled or Bust</a></li>
<li><a href="http://weblogs.asp.net/omarzabir/archive/2008/10/28/solving-common-problems-with-compiled-queries-in-linq-to-sql-for-high-demand-asp-net-websites.aspx">Solving common problems with Compiled Queries in Linq to Sql for
high demand ASP.NET
websites</a></li>
<li><a href="http://blogs.msdn.com/ricom/archive/2008/01/14/performance-quiz-13-linq-to-sql-compiled-query-cost-solution.aspx">Performance Quiz #13 -- Linq to SQL compiled query cost --
solution</a></li>
</ul>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 </div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>1088 words</span>
    <span>7 - 9 minutes read</span></div><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/posts/2010/1-de-5-000-o-5-000-de-1-batch-y-transaccional/coding-horror-official-logo-small.png">coding-horror-official-logo-small.png</a></li><li><a href="http://localhost:1313/posts/2010/1-de-5-000-o-5-000-de-1-batch-y-transaccional/performance_comp_vs_nocomp.jpg">performance_comp_vs_nocomp.jpg</a></li><li><a href="http://localhost:1313/posts/2010/1-de-5-000-o-5-000-de-1-batch-y-transaccional/zabir_argument.png">zabir_argument.png</a></li></ul><h3>Related</h3>
    <ul><li><a href="/posts/2010/la-programaci%C3%B3n-en-10-anos-mas/">La programación en 10 años más</a></li><li><a href="/posts/2010/la-disciplina-condenada/">La disciplina condenada</a></li><li><a href="/posts/2009/la-programacion-como-un-arte-parte-v-y-final/">La programación como un Arte (Parte V y final)</a></li><li><a href="/posts/2009/la-programacion-como-un-arte-parte-iv/">La programación como un Arte (Parte IV)</a></li><li><a href="/posts/2009/la-programacion-como-un-arte-parte-iii/">La programación como un Arte (Parte III)</a></li></ul></aside></div>
  </div>
</body>
</html>
