<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Chubascos de ligera intensidad | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/posts/2016/chubascos-de-ligera-intensidad/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="Chubascos de ligera intensidad">
  <meta property="og:description" content="El plan original, bueno el plan modificado del original, era implementar cada uno de los 9 desafíos en un mes. Pero la verdad es que he tenido un inicio de año bastante ocupado y mi tiempo para dedicarle a este proyecto se ha visto afectado. La primera parte de este desafío la publiqué el 31 de marzo, así que me ha tomado ¡[dos meses completar el desafío!
Si bien, no son tantas las horas efectivas dedicadas a resolver el problema, la dificultad está en la dedicación para poder sentarme, investigar y escribir el código. Espero poder retomar el ritmo de publicación en los próximos desafíos.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-05-31T08:25:11-03:00">
    <meta property="article:modified_time" content="2016-05-31T08:25:11-03:00">
    <meta property="article:tag" content="Desafíos">
    <meta property="article:tag" content="Lenguajes De Programación">
    <meta property="article:tag" content="Programación">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Erlang">
    <meta property="og:image" content="http://localhost:1313/posts/2016/chubascos-de-ligera-intensidad/featured.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/posts/2016/chubascos-de-ligera-intensidad/featured.png">
  <meta name="twitter:title" content="Chubascos de ligera intensidad">
  <meta name="twitter:description" content="El plan original, bueno el plan modificado del original, era implementar cada uno de los 9 desafíos en un mes. Pero la verdad es que he tenido un inicio de año bastante ocupado y mi tiempo para dedicarle a este proyecto se ha visto afectado. La primera parte de este desafío la publiqué el 31 de marzo, así que me ha tomado ¡[dos meses completar el desafío!
Si bien, no son tantas las horas efectivas dedicadas a resolver el problema, la dificultad está en la dedicación para poder sentarme, investigar y escribir el código. Espero poder retomar el ritmo de publicación en los próximos desafíos.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Chubascos de ligera intensidad</h1><time class="dim" datetime="2016-05-31T08:25:11-03:00">May 31, 2016</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/desaf%C3%ADos/">#desafíos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes-de-programaci%C3%B3n/">#lenguajes de programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n/">#programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/go/">#go</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/rust/">#rust</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/erlang/">#erlang</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/haskell/">#haskell</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/scala/">#scala</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/kotlin/">#kotlin</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/clojure/">#clojure</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/fsharp/">#fsharp</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/swift/">#swift</a>
      </div></ol></div>
  <section class="page-section"><p>El plan original, bueno el plan modificado del original, era implementar
cada uno de los 9 desafíos en un mes. Pero la verdad es que he tenido un
inicio de año bastante ocupado y mi tiempo para dedicarle a este
proyecto se ha visto afectado. La primera parte de este desafío la
publiqué el 31 de marzo, así que me ha  tomado ¡[dos meses  completar el
desafío!</p>
<p>Si bien, no son tantas las horas efectivas dedicadas a resolver el
problema, la dificultad está en la dedicación para poder sentarme,
investigar y escribir el código. Espero poder retomar el ritmo de
publicación en los próximos desafíos.</p>
<p>Pero lo importante es terminar lo empezado, así que acá va la segunda
parte del <a href="/blog/lnds/2016/3/31/reporte-del-clima">Reporte del Clima</a>.</p>
<p><img src="//d2dspjyoh5c79p.cloudfront.net/ba9ce4db-25ed-11e6-a13c-3371c0364c63-aa9f18b7" alt="Lee Sklar"></p>
<p>Leland Bruce &ldquo;Lee&rdquo; Sklar debe ser el más famoso de los bajistas menos
famosos del mundo del rock. De seguro lo han visto acompañando a
grandes artistas, como Phil Collins o Toto. ¡Ha participado en más de
2.000 álbumes!</p>
<p>Lee Sklar no tiene la fama de Pastorious, Flea o Geddy Lee, pero es un
bajista muy buen, por algo ha sido invitado a participar en más de 2.000
álbumes, y fue elegido por Toto para acompañarlos hace unos años
atrás.</p>
<p>Sklar es como los lenguajes que vamos a revisar a continuación, tienen
menos momentum, son conocidos por unos pocos entusiastas, son de nicho,
pero tienen características notables, que los hacen resaltar, aunque sea
por lo pintoresco (como la famosa barba de Sklar).</p>
<p>En la primera parte, resolvimos el problema de consultar el estado del
clima usando la API del sitio
<a href="//openweathermap.org/">OpenWeatherMap.org</a>. Para esto usamos como
lenguaje de implementación Scala, Go, Clojure, Rust y Swift. Los más
conocidos y usados de nuestra lista de 9
lenguajes.</p>
<p>En esta segunda parte vamos a revisar las soluciones en F#, Haskell,
Erlang y Kotlin. En una tercera parte, que publicaré en una semana más,
 revisaré otros aspectos de este desafío (como la llamada a la API
usando HTTP, y el parsing de
Xml).</p>
<h2 id="concurrencia-en-f">Concurrencia en F#</h2>
<p>Si recuerdan, tenemos dos maneras de ejecutar el programa, de manera
secuencial y en paralelo, tal como lo describí en estos dibujos</p>
<figure><img src="//d2dspjyoh5c79p.cloudfront.net/12e7677d-25f1-11e6-a13c-3371c0364c63-aa9f18b7"
    alt="Ejecución Secuencial"><figcaption>
      <p>Ejecución Secuencial</p>
    </figcaption>
</figure>

<figure><img src="//d2dspjyoh5c79p.cloudfront.net/eda1c73c-25f0-11e6-a13c-3371c0364c63-aa9f18b7"
    alt="Ejecución en Paralelo"><figcaption>
      <p>Ejecución en Paralelo</p>
    </figcaption>
</figure>

<p>Vimos que lenguajes como Clojure y Scala tienen una manera muy elegante
de realizar esto.</p>
<p>En Clojure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    ((<span style="color:#a6e22e">print-weather</span> (<span style="color:#a6e22e">sort-reports</span> (<span style="color:#a6e22e">pmap</span> weather-api r))))
</span></span></code></pre></div><p>En Scala:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>    printReports <span style="color:#f92672">(</span>cities<span style="color:#f92672">.</span>par map <span style="color:#f92672">(</span>city <span style="color:#66d9ef">=&gt;</span> apiCall<span style="color:#f92672">(</span>city<span style="color:#f92672">))).</span>toList<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>F# utiliza la infraestructura de .Net para poder paralelizar tareas.</p>
<p>Primero veamos la forma secuencial de resolver nuestro problema:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> seq_fetch cities <span style="color:#f92672">=</span> cities <span style="color:#f92672">|&gt;</span> List.map api_call
</span></span></code></pre></div><p>Para paralelizar esta tarea hacemos simplemente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> par_fetch cities <span style="color:#f92672">=</span> cities <span style="color:#f92672">|&gt;</span> List.map api_call_async  
</span></span><span style="display:flex;"><span>                                  <span style="color:#f92672">|&gt;</span> Async.Parallel <span style="color:#f92672">|&gt;</span> Async.RunSynchronously  
</span></span><span style="display:flex;"><span>                                  <span style="color:#f92672">|&gt;</span> List.ofArray
</span></span></code></pre></div><p>Notar que en vez de llamar a la función api_call, llamamos a
api_call_async. La diferencia entre ambas funciones es la siguiente</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> api_call city <span style="color:#f92672">=</span> api_call_n city 10
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> api_call_async city <span style="color:#f92672">=</span> async <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> api_call_n city 10 <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>la función api_call_n invoca la API para la ciudad que recibe como
parámetro. El número 10 corresponde a la cantidad máxima de reintentos
para llamar la api. Esta función retorna el reporte del clima para la
ciudad.</p>
<p>La diferencia es que api_call_async no ejecuta el código de inmediato,
este se ejecutará al pasar por Async.Parallel. La función
Async.RunSynchronously espera el resultado de la ejecución en paralelo y
lo entrega a List.ofArray (porque la función Async.Parallel nos entrega
un arreglo con los resultados.</p>
<p>Esto es más complejo que con Clojure o Scala, pero es simple y elegante.</p>
<h2 id="concurrencia-en-haskell">Concurrencia en Haskell</h2>
<p>Las soluciones en Haskell son muy similares, la versión secuencial es
esta:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>    process_seq api_key args <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> lreps <span style="color:#f92672">&lt;-</span> reps
</span></span><span style="display:flex;"><span>           print_reports <span style="color:#f92672">$</span>  sortBy cmp_rep lreps 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> reps <span style="color:#f92672">=</span> mapM (make_report <span style="color:#f92672">.</span> (api_call api_key)) args 
</span></span></code></pre></div><p>La versión paralela es la siguiente:</p>
<pre tabindex="0"><code>    import qualified Control.Monad.Parallel as P

    ....

    process_par api_key args =
        do lreps &lt;- preps
           print_reports $ sortBy cmp_rep lreps 
        where preps = P.mapM (make_report . (api_call api_key)) args
</code></pre><p>La diferencia está destacada en negritas.</p>
<p>La versión secuencial mapea la función compuesta (make_report .
(api_call api_key) con args.</p>
<p>La versión paralela hace exactamente lo mismo, pero hace un mapeo en
paralelo usando Control.Monad.Parallel.</p>
<p>Para entender a profundidad este problema hay que dominar el concepto de
Monadas, pero intentaré simplificar la explicación.</p>
<p>Vamos primero por la versión secuencial:</p>
<p>La declaración de la función es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     process_seq api_key args <span style="color:#f92672">=</span>
</span></span></code></pre></div><p>Define una función que recibe la clave de la API y una lista de
argumentos args (la lista de  ciudades).</p>
<p>Luego ejecutamos lo siguiente usando un bloque do<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">do</span> lreps <span style="color:#f92672">&lt;-</span> preps
</span></span><span style="display:flex;"><span>        print_reports <span style="color:#f92672">$</span> sortBy cmp_rep lreps
</span></span></code></pre></div><p>Lo primero es rescatar la lista de reportes en lreps, esta viene en la
variable preps que será definida por la sentencia where de más abajo.
Luego de rescatar la lista de reportes en lreps, los ordenamos usando la
función sortBy (que usa la función cmp_rep, que compara reportes). La
lista ordenada es el argumento para función
print_reports.</p>
<p>La sentencia where mapea la lista de ciudades a una lista
reportes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">where</span> preps <span style="color:#f92672">=</span> mapM (make_report <span style="color:#f92672">.</span> (api_call api_key)) args
</span></span></code></pre></div><p>Dividamos esto paso a paso. Recordemos que args es la lista de
ciudades. Lo que tememos acá es equivalente a
esto:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     map <span style="color:#66d9ef">F</span> cities
</span></span></code></pre></div><div>
<p>Acá F es una función compuesta: F = make_report . (api_call
api_key)</p>
<p>El operador . permite componer funciones en Haskell, en general, si
tienes una función f y otra función g, entonces (f . g) x  es
equivalente a hacer (f (g
x).</p>
<p>¿Por qué usamos mapM en vez de map?</p>
<p>Porque api_call retorna un valor de tipo IO String (esta es una
monada), la función make_report recibe un argumento de tipo IO String y
retorna un valor de tipo IO WeatherReport
(otra monada). La función mapM es como la función map, pero opera con
listas de monadas.</p>
<p>En realidad mapM recibe algo del estilo [m t] y retorna m [t], es
decir, recibe una lista de monadas de T, y retorna una monada de una
lista de T.</p>
<p>La definición de mapM es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     mapM <span style="color:#f92672">::</span> <span style="color:#66d9ef">Monad</span> m <span style="color:#f92672">=&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> [a] <span style="color:#f92672">-&gt;</span> m [b]
</span></span></code></pre></div><p>Esto explica por qué hacemos lreps &lt;- preps.<br>
La función sortBy requiere una lista pura, como preps es una monada que
contiene una lista, lo que hacemos con esta asignación es sacar la lista
fuera de la monada.</p>
<p>En general, si tenemos una monada <em>m v</em>, cuando hacemos <em>x</em> &lt;- <em>m v</em>,
asignamos <em>v</em> a <em>x</em>.</p>
<p>¿Qué es una monada? Es la pregunta común de quienes empiezan a aprender
Haskell.</p>
<p>¿Recuerdan cuando en el juego de toque y fama hicimos lo siguiente?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>    acc <span style="color:#f92672">&lt;-</span> getLine
</span></span></code></pre></div><p>Lo que ocurre es que getLine no es una función pura, algo que no nos
gusta en Haskell, una función pura no tiene efectos laterales, pero
getLine es una función que interactúa con el mundo exterior, es lo que
se llama una acción destructiva
(ver <a href="/lnds/2015/10/1/revelaciones">revelaciones</a>).
Haskell nos protege del mundo exterior a través de la monadas. En
particular la función getLine en vez de retornar un String lo que hace
es retornar una monada IO String.</p>
<p>A mi me gusta pensar en las monadas como en <em>cajas</em>. En Haskell para
conversar con el mundo exterior usamos estas cajas. La función getLine
retorna una <em>caja</em> que se llama IO cuyo contenido es un String.</p>
<p>Nuestro programa usa muchas monadas puesto que debe interactuar con el
sitio web de OpenWeatherMap, debe leer variables de ambiente del sistema
operativo, escribir en pantalla en reporte del tiempo, medir el tiempo
de ejecución de una función, etc.</p>
<p>Si no entienden mucho, no se preocupen, no traten de entender de
inmediato el concepto de monada, simplemente escriban varios programas
en Haskell que usen funciones de entrada/salida, como en este ejercicio,
todo irá calzando con el tiempo. De todas maneras, voy a escribir
después un post especial sobre Haskell donde explicaré este
concepto.</p>
<h2 id="erlang">Erlang</h2>
<p>Erlang implementa el modelo de actores para ejecutar concurrencia. Lo
que haremos es crear actores que ejecutan sólo una acción.
Tradicionalmente un actor en Erlang se mantiene en un loop recibiendo
mensajes, en este caso sólo esperamos un mensaje y terminamos.</p>
<p>Veamos primero la versión síncrona</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>    buscar_reportes_con_map(Ciudades) <span style="color:#f92672">-&gt;</span> 
</span></span><span style="display:flex;"><span>        lists:<span style="color:#a6e22e">map</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">fun</span>(Ciudad) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>               Url <span style="color:#f92672">=</span> crear_url_api(Ciudad),
</span></span><span style="display:flex;"><span>                {Xml,Error} <span style="color:#f92672">=</span> llamar_api(Url),
</span></span><span style="display:flex;"><span>              extraer_reporte(Xml, Ciudad, Error)  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>, Ciudades).
</span></span></code></pre></div><p>Es un simple mapeo de ciudades a reportes, usando una función declarada
inline. Esta función crea la Url, invoca la api y luego extrae el
reporte (que es el resultado).</p>
<p> la versión asíncrona es así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>    buscar_reportes_con_map_async(Ciudades) <span style="color:#f92672">-&gt;</span> 
</span></span><span style="display:flex;"><span>        ReqIds <span style="color:#f92672">=</span> lists:<span style="color:#a6e22e">map</span>(
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">fun</span>(Ciudad) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>               Url <span style="color:#f92672">=</span> crear_url_api(Ciudad),
</span></span><span style="display:flex;"><span>                {Ciudad,llamar_api_async(Url)}
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">end</span>, Ciudades),
</span></span><span style="display:flex;"><span>     recolectar(ReqIds).
</span></span></code></pre></div><p>La versión asíncrona ejecuta una llamada asíncrona de la API. En este
caso mapeamos ciudades a los Id de los
actores.</p>
<p>Veamos como funciona la función llamar_api_async():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>    llamar_api_async(Url) <span style="color:#f92672">-&gt;</span> spawn(<span style="color:#f92672">?</span>MODULE, async_api_call, [Url]).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    async_api_call(Url) <span style="color:#f92672">-&gt;</span>  <span style="color:#75715e">% io:format(&#34;llamando asincronamenete url: ~s\n&#34;, [Url]), % descomentar para convencerse que es asincrono
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       {Xml,Error} <span style="color:#f92672">=</span> llamar_api(Url),
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">receive</span> 
</span></span><span style="display:flex;"><span>            {From, get_result} <span style="color:#f92672">-&gt;</span> From <span style="color:#f92672">!</span> {xml, Xml, Error}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>. 
</span></span></code></pre></div><p>La función llamar_api_async invoca a la primitiva spawn, esto crea un
actor que es atendido por la función
async_api_call(Url).</p>
<p>Este actor se queda esperando el mensaje get_result. Cuando lo recibe
le envía el resultado al hacer <em>From ! {xml, Xml,
Error}.</em></p>
<p>Para terminar de entender necesitamos ver la función recolectar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>    recolectar([Llam|Llams]) <span style="color:#f92672">-&gt;</span> 
</span></span><span style="display:flex;"><span>      {Ciudad,ReqId} <span style="color:#f92672">=</span> Llam,
</span></span><span style="display:flex;"><span>      ReqId <span style="color:#f92672">!</span> {self(), get_result},
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">receive</span>
</span></span><span style="display:flex;"><span>            {xml, Xml, Error} <span style="color:#f92672">-&gt;</span> 
</span></span><span style="display:flex;"><span>                [extraer_reporte(Xml, Ciudad, Error) | recolectar(Llams)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>;
</span></span><span style="display:flex;"><span>    recolectar([]) <span style="color:#f92672">-&gt;</span> [].
</span></span></code></pre></div><p>La función recolectar recibe una lista de handles de actores. Esta
función le envía un mensaje a cada
actor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>     ReqId <span style="color:#f92672">!</span> {self(), get_result}
</span></span></code></pre></div><p>El mensaje tiene dos partes, el identificador del proceso principal
(self()) y el átomo
get_result.</p>
<p>Recordemos que cada actor responde con el mensaje {xml, Xml, Error}.En
este dibujo traté de explicar lo que pasa. El lado izquierdo inicializa
los actores (circulos pequeños de color verde). El lado derecho, explica
lo que ocurre después. En este caso se inicia enviando el mensaje
get_result a cada actor creado. Cada actor responde con el resultado de
invocar la api {xml, Xml,
Error}.</p>
<p><img src="//d2dspjyoh5c79p.cloudfront.net/666abcbe-2602-11e6-a13c-3371c0364c63-aa9f18b7" alt=""></p>
<h2 id="kotlin">Kotlin</h2>
<p>Con este lenguaje decidí usar un mecanismo similar a la solución en
Scala.</p>
<p>El código final es básicamente así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>    <span style="color:#75715e">// Solución secuencial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> reports = cities.map(<span style="color:#f92672">::</span>apiCall)
</span></span><span style="display:flex;"><span>    printReports (reports)
</span></span></code></pre></div><p>La solución paralela quedó así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>    <span style="color:#75715e">// Solución paralela
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> reports = cities.par().map(<span style="color:#f92672">::</span>apiCall)
</span></span><span style="display:flex;"><span>    printReports(reports.unpar().toList())
</span></span><span style="display:flex;"><span>    reports.executorService.shutdown()
</span></span></code></pre></div><p>En realidad Kotlin no tiene la primitiva par() para listas. Para
hacerlo usé código publicado
por Holger Brandl <a href="//github.com/holgerbrandl/kutils/blob/master/src/main/kotlin/kutils/ParCollections.kt">acá</a>.</p>
<p>Este código extiende las colecciones con la primitiva
par().</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** A delegated tagging interface to allow for parallized extension functions */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ParCol</span>&lt;T&gt;(<span style="color:#66d9ef">val</span> it: Iterable&lt;T&gt;, <span style="color:#66d9ef">val</span> executorService: ExecutorService) 
</span></span><span style="display:flex;"><span>       : Iterable&lt;T&gt; <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">it</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** Convert a stream into a parallel collection. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> &lt;<span style="color:#a6e22e">T</span>&gt; <span style="color:#a6e22e">Iterable</span>&lt;T&gt;.par(numThreads: Int = <span style="color:#a6e22e">Runtime</span>.getRuntime().availableProcessors(),
</span></span><span style="display:flex;"><span>                            executorService: ExecutorService = <span style="color:#a6e22e">Executors</span>.newFixedThreadPool(numThreads))
</span></span><span style="display:flex;"><span>    : ParCol&lt;T&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ParCol(<span style="color:#66d9ef">this</span>, executorService);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>El código usa la clase ExecutorService de Java 8. Este es un servicio
que permite trabajar con threads y código
concurrente.</p>
<p>Entonces cuando hacer lista.par(), lo que hacemos es crear una
instancia de la clase ParCol que contiene la lista y le agrega un
ExecutorService.</p>
<p>Otra extensión que agregamos es la función map():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> &lt;<span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">R</span>&gt; <span style="color:#a6e22e">ParCol</span>&lt;T&gt;.map(transform: (T) <span style="color:#f92672">-&gt;</span> R): ParCol&lt;R&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> destination = ArrayList&lt;R&gt;(<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#66d9ef">is</span> Collection&lt;*&gt;) <span style="color:#66d9ef">this</span>.size <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> futures = <span style="color:#66d9ef">this</span>.asIterable().map { 
</span></span><span style="display:flex;"><span>            executorService.submit { 
</span></span><span style="display:flex;"><span>                destination.add(transform(<span style="color:#66d9ef">it</span>)) 
</span></span><span style="display:flex;"><span>            } 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        futures.map { <span style="color:#66d9ef">it</span>.<span style="color:#66d9ef">get</span>() } <span style="color:#75715e">// this will block until all are done
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ParCol(destination, executorService)
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Acá creamos una lista de futures que son los que aplican la función
transform() a cada elemento de la
colección.</p>
<p>Luego nos quedamos esperando la ejecución de cada uno de las llamadas a
transform().</p>
<p>La función map() crea finalmente una nueva instancia de la clase
ParCol, esta vez con el resultado de la computación de transform() sobre
todos los elementos de la colección
inicial.</p>
<p>Para recuperar el resultado usamos la función unpar(), que retorna la
lista contenida dentro de la instancia de ParCol.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> &lt;<span style="color:#a6e22e">T</span>&gt; <span style="color:#a6e22e">ParCol</span>&lt;T&gt;.unpar(): Iterable&lt;T&gt; {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#66d9ef">it</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Esta implementación nos da la pista de cómo poder implementar parmap en
Java 8. ¿Alguno se animaría a solucionar este desafío usando Java 8? Si
es así lo invito a agregar su propuesta mediante un pull request a mi
repositorio: <a href="https://github.com/lnds/9d9l">https://github.com/lnds/9d9l</a>](//github.com/lnds/9d9l)</p>
<p>Comparemos los resultados en Kotlin, para medir que tan eficiente es
esta solución:</p>
<pre><code>$ java -jar weather-1.0-SNAPSHOT-all.jar  Santiago Boston Londres Valdivia Antofagasta

Boston              max: 32,0  min: 12,2   actual:  17,6 niebla
Antofagasta         max: 17,0  min: 17,0   actual:  17,0 nubes rotas
Valdivia            max: 12,0  min: 12,0   actual:  12,0 llovizna
Santiago            max: 12,0  min: 12,0   actual:  12,0 chubasco de ligera intensidad
Londres             max:  8,5  min:  8,5   actual:   8,5 nubes dispersas
tiempo ocupado para generar el reporte:  0:00:1,372
</code></pre>
<p>En Paralelo:</p>
<pre><code>$ java -jar weather-1.0-SNAPSHOT-all.jar -p Santiago Boston Londres Valdivia Antofagasta
Boston              max: 32,0  min: 12,2   actual:  17,6 niebla
Antofagasta         max: 17,0  min: 17,0   actual:  17,0 nubes rotas
Valdivia            max: 12,0  min: 12,0   actual:  12,0 llovizna
Santiago            max: 12,0  min: 12,0   actual:  12,0 chubasco de ligera intensidad
Londres             max:  8,5  min:  8,5   actual:   8,5 nubes dispersas
tiempo ocupado para generar el reporte:  0:00:0,516
</code></pre>
<p>La versión secuencial en mi equipo toma 1,372 segundos, la versión
paralela demora 0,516 segundos (menos de la mitad del tiempo!).</p>
<p>Con esto terminamos la implementación de este desafío en 9 lenguajes.
Sólo para cerrar todo publicaré otro artículo con los detalles que no
cubrí, que corresponden a cómo descargar desde una URL (usando HTTP) y
parsear un archivo XML.</p>
<h2 id="cuatro-soluciones">Cuatro Soluciones</h2>
<p>En este artículo he mostrado 4 soluciones adicionales a este problema.</p>
<p>F#:
en <a href="//github.com/lnds/9d9l/tree/master/desafio2/fsharp">https://github.com/lnds/9d9l/tree/master/desafio2/fsharp</a></p>
<p>Haskell:
en <a href="//github.com/lnds/9d9l/tree/master/desafio2/haskell">https://github.com/lnds/9d9l/tree/master/desafio2/haskell</a></p>
<p>Erlang:
en <a href="//github.com/lnds/9d9l/tree/master/desafio2/erlang">https://github.com/lnds/9d9l/tree/master/desafio2/erlang</a></p>
<p>Kotlin:
en <a href="//github.com/lnds/9d9l/tree/master/desafio2/kotlin">https://github.com/lnds/9d9l/tree/master/desafio2/kotlin</a></p>
<p><strong>Notas</strong></p>
<p>(*) Imagen del título tomada de Wikipedia autor John Kerstholt, tomado
de <a href="//commons.wikimedia.org/wiki/File:Rolling-thunder-cloud.jpg">acá</a>.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Los bloques do permiten ejecutar operaciones con las monadas, es
muy útil cuando usamos la monada IO, pero eso lo voy a explicar más
adelante.]{style=&ldquo;letter-spacing: 0.01rem; line-height: 1.5;&rdquo;}&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 </div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>2255 words</span>
    <span>15 - 19 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#concurrencia-en-f">Concurrencia en F#</a></li>
    <li><a href="#concurrencia-en-haskell">Concurrencia en Haskell</a></li>
    <li><a href="#erlang">Erlang</a></li>
    <li><a href="#kotlin">Kotlin</a></li>
    <li><a href="#cuatro-soluciones">Cuatro Soluciones</a></li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/posts/2016/chubascos-de-ligera-intensidad/featured.png">featured.png</a></li></ul><h3>Related</h3>
    <ul><li><a href="/posts/2016/reporte-del-clima/">Reporte del Clima</a></li><li><a href="/posts/2016/esos-raros-lenguajes-nuevos/">Esos Raros Lenguajes Nuevos</a></li><li><a href="/posts/2016/mas-alla-del-hola-mundo/">Más allá del Hola Mundo</a></li><li><a href="/posts/2011/cuidate-del-estilista/">Cuidate del estilista</a></li><li><a href="/posts/2011/zig-zag/">Zig Zag</a></li></ul></aside></div>
  </div>
</body>
</html>
