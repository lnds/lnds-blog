<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>En la Corte del Rey Carmesí | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/posts/2019/en-la-corte-del-rey-carmesi/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="En la Corte del Rey Carmesí">
  <meta property="og:description" content="King Crimson se formó en Londres, el 30 de noviembre de 1968, y tuvo su primer ensayo el 14 de enero de 1969, hace ya cincuenta años. La banda era heredera de Giles, Giles and Fripp, un grupo que tocaba pop con un estilo excéntrico y de alta complejidad musical. Originalmente eran un trio formado por los hermanos Michael Giles en batería y Peter Giles en bajo, juntas al guitarrista Robert Fripp. Con el tiempo quisieron expandir su sonido e incorporaron en el teclado a Ian McDonald, quien incorporó como letrista a Peter Sinfield.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-01-27T08:25:11-03:00">
    <meta property="article:modified_time" content="2019-01-27T08:25:11-03:00">
    <meta property="article:tag" content="Haskell">
    <meta property="article:tag" content="Desafíos">
    <meta property="og:image" content="http://localhost:1313/posts/2019/en-la-corte-del-rey-carmesi/featured.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/posts/2019/en-la-corte-del-rey-carmesi/featured.png">
  <meta name="twitter:title" content="En la Corte del Rey Carmesí">
  <meta name="twitter:description" content="King Crimson se formó en Londres, el 30 de noviembre de 1968, y tuvo su primer ensayo el 14 de enero de 1969, hace ya cincuenta años. La banda era heredera de Giles, Giles and Fripp, un grupo que tocaba pop con un estilo excéntrico y de alta complejidad musical. Originalmente eran un trio formado por los hermanos Michael Giles en batería y Peter Giles en bajo, juntas al guitarrista Robert Fripp. Con el tiempo quisieron expandir su sonido e incorporaron en el teclado a Ian McDonald, quien incorporó como letrista a Peter Sinfield.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>En la Corte del Rey Carmesí</h1><time class="dim" datetime="2019-01-27T08:25:11-03:00">January 27, 2019</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/haskell/">#haskell</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/desaf%C3%ADos/">#desafíos</a>
      </div></ol></div>
  <section class="page-section"><p>King Crimson se formó en Londres, el 30 de noviembre de 1968, y tuvo su
primer ensayo el <strong>14 de enero de 1969</strong>, hace ya cincuenta años. La
banda era heredera de Giles, Giles and Fripp, un grupo que tocaba pop
con un estilo excéntrico y de alta complejidad musical. Originalmente
eran un trio formado por los hermanos Michael Giles en batería y Peter
Giles en bajo, juntas al guitarrista Robert Fripp. Con el tiempo
quisieron expandir su sonido e incorporaron en el teclado a Ian
McDonald, quien incorporó como letrista a Peter Sinfield.</p>
<p>Fripp quería abandonar el pop y presionó para que Peter Giles abandonara
la banda, e invitó a Greg Lake, un viejo amigo, y ex compañero de
escuela. Como ambos tocaban guitarra (habían estudiado con el mismo
profesor) y tras la partida de Giles, decidieron que Lake tocara el bajo
y se hiciera cargo de la voz.</p>
<p>El nombre de la banda es una referencia a Belzebú, príncipe de los
demonios[1]. Pero también al hecho que un &ldquo;rey carmesí&rdquo; históricamente
refiere a un rey cuyo gobierno se caracteriza por el excesivo
derramamiento de sangre. Hay que recordar que el primer álbum de la
banda debuta en pleno periodo de la guerra de Vietnam.</p>
<p>El principal compositor era McDonald con aportes de Fripp, y las letras
de Sinfield. Fripp una vez dijo que incorporar letras a la música de
King Crimson era &ldquo;una imposibilidad funcional&rdquo;. Trabajaron intensamente,
buscando nuevos sonidos y complicadas armonías, hasta que en octubre de
1968 estrenaron &ldquo;In The Court of the Crimson King&rdquo;.</p>
<figure><img src="https://d2dspjyoh5c79p.cloudfront.net/3e6deba1-2280-11e9-a030-2b5831f8ecb5-aa9f18b7"
    alt="Imagen de la portada del primer álbum de King Crimson, la pintura es obra de Barry Godber, un programador de computadores."><figcaption>
      <p>Imagen de la portada del primer álbum de King Crimson, la pintura es obra de Barry Godber, un programador de computadores.</p>
    </figcaption>
</figure>

<p>El álbum fue un éxito, y la banda partió en tour, principalmente por
Estados Unidos. Pero este viaje provocó fisuras en la banda. Michael
Giles junto con Ian McDonald abandonaron el grupo en la mitad del tour.
De vuelta, y mientras preparaban su segundo álbum, Greg Lake decide
partir también para conformar el famoso super trio de rock progresivo
&ldquo;Emerson, Lake &amp; Palmer&rdquo;.</p>
<p>Fripp invita a Gordon Haskell, otro ex compañero de escuela, para que se
incorpore a la banda, reemplazando a Lake. A esas alturas Sinfield
estaba a cargo de los sintetizadores.</p>
<p>No fue fácil para Haskell hacerse cargo de las partes vocales de Lake, e
incluso pidió bajar el tono de algunas canciones con el fin de poder
vocalizarlas adecuadamente. La propuesta fue enérgicamente rechazada por
Fripp y ambos se distanciaron. Después Haskell diría *&ldquo;el arma de King
Crimson es el fascismo musical, seco por fascistas, diseñado por
fascistas para deshumanizar, para despojar a la humanidad de su dignidad
y alma&rdquo; *[2].</p>
<p>Eventualmente, y después de grabar &ldquo;Islands&rdquo;, el cuarto álbum de la
banda, Fripp le pide a Sinfield que abandone el grupo. Con esto Robert
Fripp se convierte en el cerebro, corazón y alma de King Crimson. </p>
<p>A pesar de contar siempre con el apoyo de músicos de gran calidad,
Fripp se negó sistemáticamente a incorporar sus composiciones, con la
idea de mantener el control de la calidad y asegurar que King Crimson
ejecutara &ldquo;el tipo correcto de música&rdquo;.</p>
<h2 id="haskell"><strong>Haskell</strong></h2>
<blockquote>
<p>&ldquo;Haskell es un compilador que transforma el narcisismo inseguro en
superioridad intelectual&rdquo; - <a href="https://twitter.com/progmofo/status/1080158952816553984">@progmofo en
Twitter</a></p></blockquote>
<p>De los lenguajes de programación que conozco**, puedo decir que
<a href="https://www.haskell.org/">Haskell</a> es uno de los más difíciles de
dominar. Probablemente escribir un programa en Haskell es como estar
ensayando en una sesión con Robert Fripp. Pero vale la pena, lo mismo
que escuchar la música de King Crimson, se los aseguro.</p>
<p>Pero, si no desafías tus gustos, tus convenciones, y todo lo que has
aprendido, ¿cómo vas a aprender?. Un colega dijo una vez, &ldquo;la
programación funcional es difícil, pero como todo lo que vale la pena en
la vida, es difícil&rdquo;.</p>
<p>En 1987, en la conferencia de Lenguajes de Programación Funcional y
Arquitectura de Computadores, se formó un comité para definir un
estándar abierto para consolidar todos los lenguajes funcionales que
existían en ese periodo (docenas).</p>
<p><img src="https://d2dspjyoh5c79p.cloudfront.net/6ac3e823-2281-11e9-a030-2b5831f8ecb5-aa9f18b7" alt=""></p>
<p>El nombre fue elegido para homenajear a Haskell Curry, un matemático y
lógico norteamericano, que trabajó en lógica combinatoria, que sirve de
fundamento para un estilo de programación funcional.</p>
<p>La primera versión de Haskell se publicó en 1990 y el trabajo continuó
hasta la liberación de Haskell 98, el primer estándar. Con esta
definición un equipo en la Universidad de Glasgow trabajó en la
implementación de GHC (&ldquo;El Glorioso Sistema de Compilación para Haskell
de Glasgow&rdquo;). El trabajo fue iniciado por Kevin Hammond, y actualmente
es liderado por Simon Peyton Jones y Simon Marlow.</p>
<p>Marlow desde 2013 trabaja en Facebook, y allí ha usado Haskell para
implementar y re implementar una serie de herramientas en ese lenguaje.
Un ejemplo notable es la máquina de reglas Sigma, que implementa
políticas de seguridad a cada interacción que ocurre cuando alguien
postea algo en la red social [3].</p>
<h2 id="héroes"><strong>Héroes</strong></h2>
<p>Fripp desbandó a King Crimson en 1974 después de liberar el álbum Red.
Después de esto trabajo en diversos proyectos, como músico de sesión y
también solista. Colaboró con Brian Eno, David Bowie, David Byrne y
Peter Gabriel entre otros, quienes admiraban el estilo de Fripp en la
guitarra.</p>
<p>Quizás, de este tiempo, lo más conocido por el público masivo es su
participación en el álbun Héroes de David Bowie, de 1977, en donde
destaca su guitarra en la canción que le da nombre al trabajo (mi
favorita de toda la obra de Bowie). Héroes es una canción representativa
de lo que hoy llamamos ara-rock. Está inspirada en la historia de una
pareja de amantes separados por el Muro de Berlin.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/2JywkrIiXW8?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<p>En 1981 Fripp decidió reformar a King Crimson, llamando de vuelta a Bill
Bruford, ex baterista de Yes, y con quien trabajó en el álbum Red. A
Bruford se unieron el gran bajista Tony Levin y Adrian Belew (a quien
Fripp conoció cuando tocaban para Peter Gabriel). Belew era un cantante
y guitarrista que había trabajado con Bowe, Talking Heads y Frank Zappa
(con quien empezó su carrera).</p>
<p>Originalmente la banda formada por Fripp, Bruford, Levin y Belew se
llamó Discipline, pero los miembros consideraban que era más adecuado
asociarla a King Crimson. Para Fripp, el nombre King Crimson ha estado
asociado a una &ldquo;forma de hacer las cosas&rdquo;, más que a un tipo particular
de grupo y músicos.</p>
<figure><img src="https://d2dspjyoh5c79p.cloudfront.net/d309f005-2281-11e9-a030-2b5831f8ecb5-aa9f18b7"
    alt="Portada del álbum Discipline"><figcaption>
      <p>Portada del álbum Discipline</p>
    </figcaption>
</figure>

<h2 id="disciplina"><strong>Disciplina</strong></h2>
<p>El primer álbum de esta nueva formación de King Crimson se llamó
Discipline. Durante cuatro años trabajaron juntos y expusieron su
trabajo en tres álbumes: Discipline, Beat, Thre of a Perfect Pair. Esta
quizás es una las formaciones de King Crimson más valoradas por sus
fans. Esta vez Fripp se abrió a los aportes de sus compañeros y
trabajaron juntos en la escritura y composición. Las letras fueron
escritas principalmente por Belew.</p>
<h3 id="sin-efectos-laterales"><strong>Sin Efectos Laterales</strong></h3>
<p>Si hay algo que caracteriza a Haskell como lenguaje de programación es
su estricta disciplina co respecto a los tipos, y la adherencia a los
principios funcionales de inmutabilidad y la falta de efectos laterales.</p>
<p>Ningún programa útil se puede construir sin efectos laterales. Por
ejemplo, imprimir en pantalla un simple mensaje implica afectar al
entorno. Para cumplir con la estricta disciplina Haskell recurre a un
concepto que permite aislar estos efectos laterales, un concepto que
viene de la Teoría de Categorías que se llama Monada (Monad).</p>
<p>Veamos el clásico ejemplo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">Module</span> <span style="color:#66d9ef">Main</span> (main) <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>     main<span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span>()
</span></span><span style="display:flex;"><span>     main <span style="color:#f92672">=</span> putStrLen <span style="color:#960050;background-color:#1e0010">“</span><span style="color:#66d9ef">Hola</span> <span style="color:#66d9ef">Mundo</span><span style="color:#960050;background-color:#1e0010">”</span>
</span></span></code></pre></div><p>En este caso al declarar la función main indicamos que su resultado es
una IO Monad, es decir, un tipo de datos que aisla un efecto lateral. Es
por esto que el compilador nos permite usar la función impura
putStrLen[4].</p>
<p>Es esta estricta disciplina la que intimida a muchos programadores, del
mismo modo que algunos músicos se sentían intimidados por el liderazgo
perfeccionista de Fripp.</p>
<h3 id="codificación-de-huffman-en-haskell"><strong>Codificación de Huffman en Haskell</strong></h3>
<p>A pesar de esa estricta disciplina, en Haskell podemos escribir
programas muy concisos. Para resolver el desafío 4 bastaron 91 lineas de
código.</p>
<p>Vamos a analizar el proceso de compresión en este artículo, el código
fuente completo está en el repositorio en
<a href="https://github.com/lnds/9d9l/tree/master/desafio4/haskell">GitHub</a>.</p>
<p>La función <strong>compress</strong> es la que recibe como parámetros el nombre del
archivo que queremos comprimir (input) y deja el resultado en un archivo
cuyo nombre viene en el segundo parámetro:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     compress input output <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>       src <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>unpack <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>readFile input
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> tree <span style="color:#f92672">=</span> buildTree <span style="color:#f92672">$</span> calcFreq src
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> table <span style="color:#f92672">=</span> <span style="color:#66d9ef">M</span><span style="color:#f92672">.</span>fromList <span style="color:#f92672">$</span> serializeTree tree
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> lookup chr <span style="color:#f92672">=</span> fromJust <span style="color:#f92672">$</span> <span style="color:#66d9ef">M</span><span style="color:#f92672">.</span>lookup chr table
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> binaryOut <span style="color:#f92672">=</span> concat <span style="color:#f92672">$</span> map lookup src
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> treeOut <span style="color:#f92672">=</span> binarizeTree tree
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> outputStream <span style="color:#f92672">=</span> padRight8 (treeOut <span style="color:#f92672">++</span> binaryOut)
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>writeFile output <span style="color:#f92672">$</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>pack <span style="color:#f92672">$</span> map fromBits (chunksOf <span style="color:#ae81ff">8</span> outputStream)
</span></span></code></pre></div><p>Esta función tiene efectos laterales, y eso se desprende del hecho que
usa la sentencia do, que siempre en Haskell indica que generaremos un
efecto lateral.</p>
<p>Lo primero es obtener todos los bytes del archivo, esto se logra con:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     src <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>unpack <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>readFile input
</span></span></code></pre></div><p>En este caso usamos LB que se declara al principio del programa
así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">import</span> <span style="color:#66d9ef">qualified</span> Data.ByteString.Lazy.Char8 <span style="color:#66d9ef">as</span> LB
</span></span></code></pre></div><p>LB tiene todo lo necesario para leer y escribir en archivos de bytes.</p>
<p>LB.unpack desempaca un storing en una secuencia de bytes, LB.readFile
lee todo el contenido de un archivo como un string. </p>
<p>El operador &lt;$&gt; es idéntico a llamar a la función fmap, y en este
caso lo que hace es crear un mapeo del string a una lista de bytes.</p>
<p>Luego debemos construir el árbol, esto se hace con:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tree <span style="color:#f92672">=</span> buildTree <span style="color:#f92672">$</span> calcFreq src
</span></span></code></pre></div><p>Notarán que en la primera linea para asignar a src usé el operador &lt;-,
pero para asignar a tree usamos let tree =, la razón es que para entrar
los valores de una Monad IO se usa &lt;-, pero con funciones puras se usa
let, que es lo estándar en Haskell. Con respecto al signo $, es para
evitar ambigüedades y está explicado en la nota [4].</p>
<p>La gracia está en la función calcFreq, la que les presento a
continuación:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     calcFreq <span style="color:#f92672">=</span> ((length <span style="color:#f92672">&amp;&amp;&amp;</span> head) <span style="color:#f92672">&lt;$&gt;</span>) <span style="color:#f92672">.</span> group <span style="color:#f92672">.</span> sort
</span></span></code></pre></div><p>El operador punto (.) denota la composición de funciones.</p>
<p>En Haskell (f . g) x es equivalente a escribir f (g x).</p>
<p>Entonces calcFreq es una función que devuelve una nueva función
compuesta por la aplicación de varias funciones.</p>
<p>Esto debe leerse de derecha a izquierda para entenderse.</p>
<p>La primera función es sort, la que ordena la entrada.</p>
<p>La segunda función es group, que agrupa los elementos ordenados.</p>
<p>Supongamos que nuestro archivo contiene la frase:</p>
<pre><code> cat's foot iron claw
</code></pre>
<p>Entonces sort produce:</p>
<pre><code>  aaccfilnooosttw'
</code></pre>
<p>Luego group produce:</p>
<pre><code>  (aa)(cc)(f)(I)(n)(ooo)(s)(tt)(w)
</code></pre>
<p>(length &amp;&amp;&amp; head) es lo que se conoce técnicamente como un Arrow, el
operador &amp;&amp;&amp; aplica las dos funciones que recibe como parámetros y
genera una dupla con los valores obtenidos, entonces</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>    (length <span style="color:#f92672">&amp;&amp;&amp;</span> head) (ooo) <span style="color:#f92672">=&gt;</span> (<span style="color:#ae81ff">3</span>, o)
</span></span></code></pre></div><p>La función length calcula el largo de una lista, y head obtiene el
primer elemento de esta.</p>
<p>Al hacer &lt;$&gt;,  mapeamos cada elemento con el Arrow
(length &amp;&amp;&amp; head).</p>
<p>Es decir, al hacer ((length &amp;&amp;&amp; head) &lt;$&gt;) sobre
(aa)(cc)(f)(I)(n)(ooo)(s)(tt)(w) obtenemos:</p>
<pre><code>  ((2, a), (2,c),(1,f),(1,l),(1,n),(3,o),(1,s),(2,t),(1,w))
</code></pre>
<p>La función buildTree es la siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     buildTree <span style="color:#f92672">=</span> htree <span style="color:#f92672">.</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>fromList <span style="color:#f92672">.</span> map (second <span style="color:#66d9ef">Leaf</span>)
</span></span></code></pre></div><p>Para entender lo que hace esta función debemos introducir el tipo de
datos HTree, que se declara así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">data</span> <span style="color:#66d9ef">HTree</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Leaf</span> a <span style="color:#f92672">|</span> <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">HTree</span> a) (<span style="color:#66d9ef">HTree</span> a)
</span></span></code></pre></div><p>Explicamos que hace buildTree entonces.</p>
<p>El map (second Leaf) lo que hace es que cada segundo elemento de las
duplas de entradas se convierten en hojas:</p>
<pre><code> ((2, a), (2,c),(1,f),(1,l),(1,n),(3,o),(1,s),(2,t),(1,w))
</code></pre>
<p>Quedando así:</p>
<pre><code> ((2, Leaf a), (2, Leaf c),(1, Leaf f),(1, Leaf l),(1, Leaf n),(3, Leaf o),(1,Leaf s),(2, Leaf t),(1, Leaf w))
</code></pre>
<p>La función <a href="http://S.fr">S.fr</a>omList simplemente convierte esta lista en
un conjunto, lo que permite operar con la función htree.</p>
<p>La función htree se define así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     htree ts
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>null ts_1 <span style="color:#f92672">=</span> t1
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">=</span> htree ts_3
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        ((w1, t1), ts_1) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin ts
</span></span><span style="display:flex;"><span>        ((w2, t2), ts2) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin ts_1
</span></span><span style="display:flex;"><span>        ts3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>insert (w1 <span style="color:#f92672">+</span> w2, <span style="color:#66d9ef">Branch</span> t1 t2) ts_2
</span></span></code></pre></div><p>Acá hemos implementado el algoritmo de Huffman. Primero hay que entender
lo que hacen las expresiones que vienen después de la sentencia where.</p>
<p>Recordemos que Haskell hace pattern matching, por lo tanto podemos ver
que:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     ((w1, t1), ts_1) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin ts
</span></span></code></pre></div><p>Extrae el nodo con el mínimo valor del conjunto. En nuestro ejemplo esto
resultaría así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     ((w1, t1), ts_1) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> f),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> l),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>     ((w1, t1), ts_1) <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> f), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> l),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>     (w1<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, t1<span style="color:#f92672">=</span><span style="color:#66d9ef">Leaf</span> f)
</span></span><span style="display:flex;"><span>     ts_1 <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> l),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span></code></pre></div><p>La siguiente expressión es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>      ((w2, t2), ts_2) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin ts_1
</span></span></code></pre></div><p>Que en nuestro ejemplo resultaría en:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>       ((w2, t2), ts_2) <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>deleteFindMin    ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> l),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>     ((w2, t2), ts_2) <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> l),  ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w)))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">=&gt;</span> (w2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">Leaf</span> l)
</span></span><span style="display:flex;"><span>     ts_2 <span style="color:#f92672">=</span>  ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span></code></pre></div><p>La tercera expresión es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     ts_3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>insert (w1 <span style="color:#f92672">+</span> w2, <span style="color:#66d9ef">Branch</span> t1 t2) ts_2
</span></span></code></pre></div><p>Lo que, en el ejemplo que estamos viendo resultaría en:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>           ts_3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>insert (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Leaf</span> f) (<span style="color:#66d9ef">Leaf</span> l))   ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">=&gt;</span> ts_3 <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Branch</span> (<span style="color:#66d9ef">Leaf</span> f) (<span style="color:#66d9ef">Leaf</span> l)),     (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> a), (<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> c), (<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> n),(<span style="color:#ae81ff">3</span>, <span style="color:#66d9ef">Leaf</span> o),(<span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">Leaf</span> s),(<span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">Leaf</span> t),(<span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Leaf</span> w))
</span></span></code></pre></div><p>Dadas estas expresiones, podemos entender el cuerpo de la función htree:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     htree ts
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> <span style="color:#66d9ef">S</span><span style="color:#f92672">.</span>null ts_1 <span style="color:#f92672">=</span> t1
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">=</span> htree ts_3 
</span></span></code></pre></div><p>Esta es una función recursiva. Lo que nos dice que si el conjunto que
recibe es vacío entonces toma el elemento t1 (que corresponde a la hoja
con el valor mínimo). De lo contrario aplica recursivamente htree al
resto del conjunto.</p>
<p>A estas alturas, si es que han llegado hasta acá, me deben estar odiando
tanto como Gordon Haskell odiaba a Robert Fripp al salir de King
Crimson, pero les pido un poco más de calma.</p>
<p>Lo que hacemos con esta extraña función es simplemente un loop, que va
construyendo el árbol desde la lista de frecuencias, de modo que el
valor mínimo quede siempre en la raíz. Les sugiero que para entenderlo
expandan el ejemplo hasta llegar al final.</p>
<p>Con esto hemos armado nuestro árbol de Huffman.</p>
<p>Volvamos a la función compress, la siguiente expresión es:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> table <span style="color:#f92672">=</span> <span style="color:#66d9ef">M</span><span style="color:#f92672">.</span>fromList <span style="color:#f92672">$</span> serializeTree tree
</span></span></code></pre></div><p>No voy a explicar serializeTree, sólo baste decir que convierte el árbol
en una tabla de duplas en que el primer valor es el carácter a
comprimir, y el segundo elemento de la dupla es su representación como
una lista de ceros y unos.</p>
<p>De ese modo obtenemos la tabla de conversión.</p>
<p>Para poder aplicarla usaremos una función auxiliar que es la que se
define en la siguiente expresión:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> lookup chr <span style="color:#f92672">=</span> fromJust <span style="color:#f92672">$</span> <span style="color:#66d9ef">M</span><span style="color:#f92672">.</span>lookup chr table
</span></span></code></pre></div><p>La función lookup recibe un carácter y lo busca en la tabla. La función
fromJust es necesaria porque M.lookup retorna una estructura de tipo
Just. Este es una construcción estándar para saber si un elemento está o
no en un diccionario en Haskell.</p>
<p>Con esto podemos generar la salida comprimida, expresada como una cadena
de bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> binaryOut <span style="color:#f92672">=</span> concat <span style="color:#f92672">$</span> map lookup src
</span></span></code></pre></div><p>Lo que hace esto es mapear cada carácter en una lista de bits, luego
junta todas las listas en una sola, que se llama binaryOut.</p>
<p>Debemos capear el árbol también en una secuencia de bits, y para eso
llamamos a la función binarizeTree</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> treeOut <span style="color:#f92672">=</span> binarizeTree tree
</span></span></code></pre></div><p>Con esto podemos armar nuestra salida, que es una gran lista de bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> outputStream <span style="color:#f92672">=</span> padRight8 (treeOut <span style="color:#f92672">++</span> binaryOut)
</span></span></code></pre></div><p>Podría ocurrir que nuestra salida sea algo así</p>
<pre><code> [1,0,1,1,0,0,0,1,0,1]
</code></pre>
<p>Con 10 valores, pero necesitamos que el tamaño de la salida sea un
múltiplo de 8, pues los bytes son de ocho. Lo que hace la función
padRigh8 es agregar ceros a la derecha hasta alcanzar un largo múltiplo
de 8:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>]
</span></span></code></pre></div><p>Esto es necesario porque cuando escribimos finalmente en resultado a un
archivo hacemos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>writeFile output <span style="color:#f92672">$</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>pack <span style="color:#f92672">$</span> map fromBits (chunksOf <span style="color:#ae81ff">8</span> outputStream)
</span></span></code></pre></div><p>La función chunksOf agrupa la salida en lotes de 8 bits.</p>
<p>El resto del programa está en
GitHub: <a href="https://github.com/lnds/9d9l/blob/master/desafio4/haskell/src/Main.hs">[https://github.com/lnds/9d9l/blob/master/desafio4/haskell/src/Main.hs]{auto-link=&ldquo;true&rdquo;
href=&ldquo;https://github.com/lnds/9d9l/blob/master/desafio4/haskell/src/Main.hs&rdquo;}</a></p>
<h2 id="radical-action-to-unseat-the-hold-of-monkey-mind"><strong>Radical Action to Unseat the Hold of Monkey Mind</strong></h2>
<p>La última encarnación de King Crimson tiene la particularidad de incluir
tres baterías. Entre los cuales se incluye a Gavin Harrison, el ex
baterista de Porcupine Tree (de quienes hablamos antes <a href="/blog/lnds/2017/8/29/occams-razor">cuando
resolvimos este problema en
Clojure</a>). Robert
Fripp colaboró con Porcupine Tree en el álbum Fear of a Blank Planet.</p>
<p>El trabajo de King Crimson hoy en día se aprecia en sus conciertos en
vivo, que son esperados con ansiedad por sus admiradores. A pesar de lo
que pudo decir Gordon Haskell de la banda, lo cierto es que esta se ha
convertido en una agrupación de culto, venerada y admirada por grandes
músicos, y es casi obligatorio conocerla por cualquiera que aprecie el
rock progresivo.</p>
<p>Pero no es música fácil de seguir, es por esto mismo que he decidido
asociar Haskell con King Crimson. Porque no es fácil seguir y aprender,
pero si quieres mejorar y profundizar tus conocimientos de programación
funciona, es casi obligatorio escribir algo de código en este lenguaje.</p>
<h2 id="fin-al-desafío-4"><strong>Fin al desafío 4</strong></h2>
<p>Con este artículo cerramos el desafío cuatro, de nueve, en esta serie.
Para finalizar voy a compartir el ranking de este desafío.</p>
<h3 id="por-tiempo-de-ejecución">Por tiempo de ejecución</h3>
<p>(del más rápido al más lento)</p>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>lenguaje</th>
          <th>Tiempo Compresión</th>
          <th>Tiempo Descompresión</th>
          <th>Total</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>Rust</td>
          <td>0.035s</td>
          <td>0.050s</td>
          <td>0.085s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Go</td>
          <td>0.089s</td>
          <td>0.141s</td>
          <td>0.230s</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Kotlin2</td>
          <td>0.200s</td>
          <td>0.212s</td>
          <td>0.412s</td>
      </tr>
      <tr>
          <td>4</td>
          <td>Kotlin</td>
          <td>0.199s</td>
          <td>0.224s</td>
          <td>0.423s</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Scala</td>
          <td>0.493s</td>
          <td>0.463s</td>
          <td>0.956s</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Scala2</td>
          <td>0.529s</td>
          <td>0.468s</td>
          <td>0.997s</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Swift</td>
          <td>0.723s</td>
          <td>1.011s</td>
          <td>1.734s</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Haskell</td>
          <td>2.384s</td>
          <td>0.809s</td>
          <td>3.193s</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Erlang</td>
          <td>2.069s</td>
          <td>2.156s</td>
          <td>4.225s</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Clojure</td>
          <td>6.973s</td>
          <td>4.960s</td>
          <td>11.933s</td>
      </tr>
      <tr>
          <td>11</td>
          <td>F#</td>
          <td>3.942s</td>
          <td>8.938s</td>
          <td>12.880s</td>
      </tr>
  </tbody>
</table>
<p>Por lineas de código</p>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>Lenguaje</th>
          <th>Lineas</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>Erlang</td>
          <td>69</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Haskell</td>
          <td>91</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Clojure</td>
          <td>152</td>
      </tr>
      <tr>
          <td>4</td>
          <td>F#</td>
          <td>197</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Kotlin</td>
          <td>267</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Scala</td>
          <td>280</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Swift</td>
          <td>334</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Rust</td>
          <td>336</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Go</td>
          <td>338</td>
      </tr>
  </tbody>
</table>
<p>Con esto avanzamos en un proyecto iniciado hace ya tres años
(<a href="https://www.lnds.net/blog/lnds/2016/1/9/esos-raros-lenguajes-nuevos)">https://www.lnds.net/blog/lnds/2016/1/9/esos-raros-lenguajes-nuevos)</a>.
Espero este año recuperar el tiempo perdido y terminar de una vez estos
9 desafíos. Los espero.</p>
<h2 id="notas">NOTAS:</h2>
<p>[1] Según Fripp la palabra Belzebú viene del árabe B&rsquo;il Sabab, que
quiere decir &ldquo;el hombre con un propósito&rdquo;</p>
<p>[2] Tomado de
<a href="https://news.avclub.com/how-king-crimson-s-musical-fascism-led-to-its-early-d-1798263566">https://news.avclub.com/how-king-crimson-s-musical-fascism-led-to-its-early-d-1798263566</a></p>
<p>[3] Fighting Spam with Haskell
<a href="https://code.fb.com/security/fighting-spam-with-haskell/">https://code.fb.com/security/fighting-spam-with-haskell/</a></p>
<p>[4] Una función impura es aquella que tiene efectos laterales.</p>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Eduardo Díaz</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>3134 words</span>
    <span>19 - 24 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#haskell"><strong>Haskell</strong></a></li>
    <li><a href="#héroes"><strong>Héroes</strong></a></li>
    <li><a href="#disciplina"><strong>Disciplina</strong></a>
      <ul>
        <li><a href="#sin-efectos-laterales"><strong>Sin Efectos Laterales</strong></a></li>
        <li><a href="#codificación-de-huffman-en-haskell"><strong>Codificación de Huffman en Haskell</strong></a></li>
      </ul>
    </li>
    <li><a href="#radical-action-to-unseat-the-hold-of-monkey-mind"><strong>Radical Action to Unseat the Hold of Monkey Mind</strong></a></li>
    <li><a href="#fin-al-desafío-4"><strong>Fin al desafío 4</strong></a>
      <ul>
        <li><a href="#por-tiempo-de-ejecución">Por tiempo de ejecución</a></li>
      </ul>
    </li>
    <li><a href="#notas">NOTAS:</a></li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/posts/2019/en-la-corte-del-rey-carmesi/featured.png">featured.png</a></li></ul></aside></div>
  </div>
</body>
</html>
