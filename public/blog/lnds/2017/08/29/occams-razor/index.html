<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Occam&#39;s Razor | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/blog/lnds/2017/08/29/occams-razor/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="Occam&#39;s Razor">
  <meta property="og:description" content="Porcupine Tree y Steven Wilson La historia de Porcupine Tree es curiosa. Nació en 1987 como una suerte de elaborada broma (hoax band) creada por Steven Wilson y Malcolm Stock.
Steven Wilson, creador de Porcupine Tree
Los dos amigos elaboraron una detallada historia sobre una supuesta banda sicodélica de los setenta, que llamaron Porcupine Tree.
Este recuento contenía coloridas anécdotas sobre eventos, participaciones en festivales de rock, y por supuesto estadías en prisión. Cuando Wilson tuvo su propio equipo de estudio grabó varias horas de material musical, con el fin de entrega “evidencias” de la existencia de la banda.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-08-29T08:25:11-03:00">
    <meta property="article:modified_time" content="2017-08-29T08:25:11-03:00">
    <meta property="article:tag" content="Desafios">
    <meta property="article:tag" content="Lenguajes Nuevos">
    <meta property="article:tag" content="Lenguajes">
    <meta property="article:tag" content="Lenguajes De Programación">
    <meta property="article:tag" content="Programación">
    <meta property="article:tag" content="Rock">
    <meta property="og:image" content="http://localhost:1313/blog/lnds/2017/08/29/occams-razor/featured.jpeg">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/blog/lnds/2017/08/29/occams-razor/featured.jpeg">
  <meta name="twitter:title" content="Occam&#39;s Razor">
  <meta name="twitter:description" content="Porcupine Tree y Steven Wilson La historia de Porcupine Tree es curiosa. Nació en 1987 como una suerte de elaborada broma (hoax band) creada por Steven Wilson y Malcolm Stock.
Steven Wilson, creador de Porcupine Tree
Los dos amigos elaboraron una detallada historia sobre una supuesta banda sicodélica de los setenta, que llamaron Porcupine Tree.
Este recuento contenía coloridas anécdotas sobre eventos, participaciones en festivales de rock, y por supuesto estadías en prisión. Cuando Wilson tuvo su propio equipo de estudio grabó varias horas de material musical, con el fin de entrega “evidencias” de la existencia de la banda.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Occam&#39;s Razor</h1><time class="dim" datetime="2017-08-29T08:25:11-03:00">August 29, 2017</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tag/desafios/">#desafios</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/lenguajes-nuevos/">#lenguajes nuevos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/lenguajes/">#lenguajes</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/lenguajes-de-programaci%C3%B3n/">#lenguajes de programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/programaci%C3%B3n/">#programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/rock/">#rock</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/clojure/">#clojure</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/programaci%C3%B3n-funcional/">#programación funcional</a>
      </div></ol></div>
  <section class="page-section"><h2 id="porcupine-tree-y-steven-wilson">Porcupine Tree y Steven Wilson</h2>
<p>La historia de Porcupine Tree es curiosa. Nació en 1987 como una suerte
de elaborada broma (hoax band) creada por Steven Wilson y Malcolm Stock.</p>
<figure><img src="https://d2dspjyoh5c79p.cloudfront.net/c142f0bb-8c19-11e7-a030-2b5831f8ecb5-aa9f18b7"
    alt="Steven Wilson, creador de Porcupine Tree"><figcaption>
      <p>Steven Wilson, creador de Porcupine Tree</p>
    </figcaption>
</figure>

<p>Los dos amigos elaboraron una detallada historia sobre una supuesta
banda sicodélica de los setenta, que llamaron Porcupine Tree.</p>
<p>Este recuento contenía coloridas anécdotas sobre eventos,
participaciones en festivales de rock, y por supuesto estadías en
prisión. Cuando Wilson tuvo su propio equipo de estudio grabó varias
horas de material musical, con el fin de entrega &ldquo;evidencias&rdquo; de la
existencia de la banda.</p>
<p>Aunque Stocks participó con algunos pasajes vocales y algo de guitarras
experimentales, su rol en el proyecto fue principalmente el
de proporcionar ideas, la mayor parte del material fue escrito, grabado
y ejecutado por Steven Wilson.</p>
<p>La idea de Wilson con este proyecto era emular lo que hicieron
<a href="https://es.wikipedia.org/wiki/XTC">XTC</a> con
<a href="https://en.wikipedia.org/wiki/The_Dukes_of_Stratosphear">The Dukes of Stratosphear</a>,
una banda modelada en base a los grupos pop sicodélicos de los sesenta.
Recién en 1989 empezó a considerar la idea de formar una banda, pero
antes lanzó un cassette de ochenta minutos de duración titulado
&ldquo;<a href="https://en.wikipedia.org/wiki/Tarquin%27s_Seaweed_Farm">Tarquin&rsquo;s Seaweed Farm</a>&rdquo;, el que
incluía un folleto de ocho páginas con más historias falsas sobre la
banda, manteniendo aún el espíritu de la broma. Esta grabación circuló
entre algunos conocidos de Wilson, pero fue suficiente para generar
cierto interés por este misterioso grupo.</p>
<p>Y fue así como entre 1991 y 1997 se formó y consolidó Porcupine Tree
como una banda real, con la dirección de Wilson, quien además actuaba de
vocalista y primera guitarra, Richard Barbieri en teclados, Colin Edwin
en bajo y Chris Maitland en batería. Esta formación se mantuvo hasta
2002, cuando Maitland abandona el grupo y se incorpora el gran baterista
Gavin Harrison. Es en el periodo del 2002 hasta 2010 donde el estilo de
Porcupine Tree se consolida y se publican sus álbumes más exitosos, como
In Absentia, Deadwing, el reconocido Fear of a Blank Planet y The
Incident.</p>
<p><img src="https://d2dspjyoh5c79p.cloudfront.net/f076ae3c-8c19-11e7-a030-2b5831f8ecb5-aa9f18b7" alt=""></p>
<p>Pero este post no es sobre Porcupine Tree, así que sigamos.</p>
<h2 id="occams-razor">Occam&rsquo;s Razor</h2>
<p>Occam&rsquo;s Razor, la Navaja de Occam, es el primer tema de
<a href="https://en.wikipedia.org/wiki/The_Incident_(album)">The Incident</a>, una pieza
instrumental de menos de dos minutos, que antecede a la canción The
Blind House. Con respecto a este título Steven Wilson declaró lo
siguiente:</p>
<blockquote>
<p>&ldquo;Todo el asunto sobre Occam&rsquo;s Razor para mi es que es una suerte de
preludio a The Blind House, una canción que trata sobre un culto
religioso. He escrito algunas canciones en estos años sobre mis
sentimientos con respecto a la religión organizada. [...]  lo
interesante sobre Occam&rsquo;s Razor es que si aplicas sus principios
sobre la religión la Navaja de Occam básicamente dice que cualquiera
que sea la más obvia, aceptable y lógica de las explicaciones es la
que debes aceptar como correcta. Hay muchas teorías para explicar
algo, tienes que descartar todas esas para las que no hay suficiente
evidencia o parecen implausibles y aceptar aquella que tiene el mayor
peso científico. Si aplicas este principio a la creación del universo
y porqué los seres humanos están acá, Dios y la religión está como en
la posición 50.000 en una lista de explicaciones plausibles[...]&rdquo;</p></blockquote>
<p>El término de <a href="https://es.wikipedia.org/wiki/Navaja_de_Ockham">la Navaja de Occam</a> nos habla sobre
descartar las explicaciones enrevesadas, sobre descartar la
complejidad. </p>
<p>En su forma más pura la Navaja de Occam dice lo siguiente:</p>
<blockquote>
<p>&ldquo;Cuando te enfrentes a hipótesis competidoras, selecciona la que haga
menos suposiciones. No multipliques entidades sin necesidad.&rdquo;</p></blockquote>
<p>Este concepto, acuñado por el filósofo medieval
<a href="https://es.wikipedia.org/wiki/Guillermo_de_Ockham">Guillermo de Ockham</a>, nos lleva al
segundo protagonista de este post, Rich Hickey, el autor de Clojure.</p>
<h2 id="simple-made-easy">Simple Made Easy</h2>
<p>Rich Hickey es el creador de Clojure, el lenguaje que usaremos para
resolver nuestro desafío cuatro.</p>
<figure><img src="https://d2dspjyoh5c79p.cloudfront.net/a599f25a-8c19-11e7-a030-2b5831f8ecb5-aa9f18b7"
    alt="Rich Hickey, creador de Clojure"><figcaption>
      <p>Rich Hickey, creador de Clojure</p>
    </figcaption>
</figure>

<p>En la <a href="/blog/lnds/2017/06/10/pour-some-syntactic-sugar-on-me">primera parte</a>
de esta serie introduje el problema y presenté la solución en Kotlin. En
la <a href="/blog/lnds/2017/7/17/close-to-the-edge-down-to-the-river">segunda parte</a>
expuse la solución en Scala.</p>
<p>Es el momento de resolver la codificación Huffmann usando Clojure, el
tercero de nuestros lenguajes basados en la JVM (Java Virtual Machine).</p>
<p>Una de las cosas que me gustan de <a href="https://clojure.org/">Clojure</a> es su
simpleza. Rich Hickey nos dice en su charla
<a href="https://www.infoq.com/presentations/Simple-Made-Easy">&ldquo;Simple Made Easy&rdquo;</a>, que
debemos buscar la simplicidad, porque ésta es un requisito para la
confiabilidad.</p>
<p>Lo simple a menudo es tomado de forma errónea por lo &ldquo;fácil&rdquo;. Pero
fácil significa que es lo que tenemos más a mano, algo que es accesible.
Por otro lado &ldquo;Simple&rdquo; es lo opuesto a lo &ldquo;Complejo&rdquo;, y lo complejo
es algo que está enrevesado (algo lioso, confuso, enredado o
intrincado). Así que simple no es lo mismo que fácil.</p>
<p>Para Hickey lo que importa en el software es:</p>
<ul>
<li>¿hace lo que se supone que debe hacer?</li>
<li>¿es de alta calidad?</li>
<li>¿es confiable?</li>
<li>¿se pueden resolver los problemas en el camino?</li>
<li>¿pueden cambiar los requerimientos a lo largo del tiempo?</li>
</ul>
<p>La respuesta a estas preguntas es lo que importa cuando escribimos
software, no el &ldquo;look and feel&rdquo; de la experiencia de escribir el
código o las implicaciones culturales de esto.</p>
<p>Los beneficios de la simplicidad son:</p>
<ul>
<li>facilidad de entendimiento</li>
<li>facilidad para el cambio</li>
<li>facilidad para depurar</li>
<li>flexibilidad</li>
</ul>
<p>Para construir sistemas simples debemos descartar esas construcciones
complejas, como el estado, los objetos, los métodos, la sintaxis, la
herencia, las variables, los loops imperativos, actores, ORM,
condicionales.</p>
<p>Para Hickey las construcciones simples son: Valores, Funciones, Espacios
de nombres, Datos, Polimorfismo, Referencias Administradas, Funciones
sobre conjuntos, Colas, Manipulación de datos declarativos, Reglass y
Consistencia.</p>
<p>Los sistemas simples se construyen mediante la abstracción, hay que
diseñar respondiendo las preguntas clásicas: qué, quién, cuándo, dónde,
por qué y cómo. Luego se eligen construcciones que generen artefactos
simples.</p>
<p>Así como Guillermo de Ockham al plantear su famoso principio nos invita
a desechar aquellas hipótesis menos enrevesadas y que no compliquemos
nuestros razonamientos invocando a más entidades que las necesarias,
Rich Hickey nos invita a hacer algo similar con el software.</p>
<p>Es por esto que Clojure es un lenguaje tan interesante, y es lo que hace
que valga la pena aprenderlo.</p>
<h1 id="desafío-4-en-clojure">Desafío 4 en Clojure</h1>
<p>Veamos cómo aplica todo esto en el contexto del problema que estamos
solucionando.</p>
<p>Recordemos que lo que queremos es implementar una forma de compresión de
archivos de texto usando la codificación de Huffman.</p>
<p>La compresión es muy sucinta en Clojure, y para mi al menos queda muy
clara:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#66d9ef">defn </span>compress [input output]
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">let </span>[bytes (<span style="color:#a6e22e">read-bytes</span> input)
</span></span><span style="display:flex;"><span>            freq (sort-by val &lt;  (<span style="color:#a6e22e">frequencies</span> bytes))
</span></span><span style="display:flex;"><span>            leaves (map (partial apply leaf) freq)
</span></span><span style="display:flex;"><span>            tree (<span style="color:#a6e22e">make-tree</span> leaves)
</span></span><span style="display:flex;"><span>            codes (<span style="color:#a6e22e">make-codes</span> tree)]
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">write-encoded</span> output (<span style="color:#a6e22e">flatten</span> [(<span style="color:#a6e22e">tree-as-bits</span> tree)
</span></span><span style="display:flex;"><span>                                        (<span style="color:#a6e22e">encode-bits</span> codes bytes)] ))))
</span></span></code></pre></div><p>Vamos a desglosar esto por parte:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>        (<span style="color:#66d9ef">let </span>[bytes (<span style="color:#a6e22e">read-bytes</span> input)
</span></span></code></pre></div><p>Es simplemente leer todos los bytes del archivo en un arreglo, esta es
una función propia construida en base la biblioteca java.nio, y pueden
encontrarla en el namespace huffman.io.</p>
<p>Una vez obtenidos los caracteres del archivo calculamos su frecuencia:\</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>              freq (sort-by val &lt;  (<span style="color:#a6e22e">frequencies</span> bytes))
</span></span></code></pre></div><p>La función frecuencies recibe un arreglo de bytes y devuelve un arreglo
de pares en que coloca cada elemento único y su frecuencia.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>Esta tabla de frecuencias la ordenamos de mayor a menor para esto usamos
sort-by, con val y &lt; como argumentos, val es la función que obtiene el
valor de frecuencia de la lista de pares devuelta por frecuencies, &lt; es
la función usada para comparar dos valores.</p>
<p>Luego convertimos estas frecuencias en hojas de nuestro árbol:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>            leaves (map (partial apply leaf) freq)
</span></span></code></pre></div><p>Acá usamos la función leaf que se define así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>leaf <span style="color:#e6db74">\[</span>symbol freq<span style="color:#e6db74">\]</span> (list <span style="color:#e6db74">:leaf</span> freq symbol))
</span></span></code></pre></div><p>Es decir, una hoja (leaf) es una lista que contiene una etiqueta :leaf,
luego la frecuencia y en la tercera posición el símbolo.</p>
<p>Al hacer (map (partial apply leaf) freq) usamos la función map para
crear un nuevo arreglo de hojas a partir de un arreglo de frecuencias.</p>
<p>Con las hojas generamos el árbol:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    tree (<span style="color:#a6e22e">make-tree</span> leaves)
</span></span></code></pre></div><p>La función make-tree se define así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#66d9ef">defn </span>make-tree [leaves]
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">loop </span>[trees leaves]
</span></span><span style="display:flex;"><span>          (<span style="color:#66d9ef">if </span>(= <span style="color:#ae81ff">1</span> (count trees))
</span></span><span style="display:flex;"><span>            (first trees)
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">recur</span> (<span style="color:#a6e22e">sort-tree</span> (cons (node (first trees) (second trees)) (drop <span style="color:#ae81ff">2</span> trees)))))))
</span></span></code></pre></div><p>Esto aplica el loop del algoritmo para construir un árbol de
codificación de huffman. Mientras el largo del arreglo sea mayor a uno,
tomamos los dos primeros nodos y construimos un nuevo nodo que los tiene
de hijos, eso es lo que hace la función node:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#66d9ef">defn </span>weight [node] (second node))(<span style="color:#66d9ef">defn </span>node [left right] (list <span style="color:#e6db74">:node</span> (+ (<span style="color:#a6e22e">weight</span> left) (<span style="color:#a6e22e">weight</span> right))  left right))
</span></span></code></pre></div><p>Un nodo, entonces, es una lista con una etiqueta :node seguido de la
suma de las frecuencias de su nodo izquierdo y del nodo derecho, luego
el nodo izquierdo y el nodo derecho. (La función weight retorna la
frecuencia de un nodo o de una hoja, que siempre corresponde al segundo
elemento de la lista).</p>
<p>Ahora hay que construir la tabla de códigos, esto se hace con la función
make-codes la que recibe el árbol:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    codes (<span style="color:#a6e22e">make-codes</span> tree)]
</span></span></code></pre></div><p>La función make-codes es como sigue:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#66d9ef">defn </span>make-codes
</span></span><span style="display:flex;"><span>      ([tree] (<span style="color:#a6e22e">make-codes</span> tree []))
</span></span><span style="display:flex;"><span>      ([tree code]
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">leaf?</span> tree)
</span></span><span style="display:flex;"><span>          {(<span style="color:#a6e22e">sym</span> tree) code}
</span></span><span style="display:flex;"><span>          (<span style="color:#a6e22e">conj</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">make-codes</span> (<span style="color:#a6e22e">left-node</span> tree) (conj code <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>            (<span style="color:#a6e22e">make-codes</span> (<span style="color:#a6e22e">right-node</span> tree) (conj code <span style="color:#ae81ff">1</span>))))))
</span></span></code></pre></div><p>Esta es una función que puede ser invocada de dos maneras, una externa
en que sólo recibe el árbol y en ese caso llama a la versión interna que
recibe el árbol además del código.</p>
<p>En el caso de la función interna tenemos dos caso, que el árbol sea una
hoja, en cuyo caso el resultado es un par con el símbolo y el código,
pero como una tupla hash-ref, esto permite armar un diccionario que nos
permite mapear los símbolos a sus representaciones binarias.</p>
<p>Si el árbol es un nodo, entonces el resultado es un diccionario con los
códigos del lado izquierdo del árbol (que empiezan con 0) junto a los
códigos del lado derecho del árbol (que empiezan con 1).</p>
<p>Ahora viene la parte final:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#a6e22e">write-encoded</span> output (<span style="color:#a6e22e">flatten</span> [(<span style="color:#a6e22e">tree-as-bits</span> tree)
</span></span><span style="display:flex;"><span>                                    (<span style="color:#a6e22e">encode-bits</span> codes bytes)] ))
</span></span></code></pre></div><p>La función write-encoded recibe un arreglo de bits (0&rsquo;s y 1&rsquo;s) y lo
escribe en el archivo output.</p>
<p>El arreglo de 0s y 1s se obtiene a partir de dos partes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#a6e22e">tree-as-bits</span> tree)
</span></span></code></pre></div><p>x
Es una función que transforma el árbol en una secuencia de 0s y 1s, y
luego:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#a6e22e">encode-bits</span> codes bytes)
</span></span></code></pre></div><p>que transforma cada byte en su representación binaria en el código de
huffman.  Cómo cada representación es un arreglo, esto genera un arreglo
de arreglos de 0s y 1s, para obtener un arreglo plano de ceros y unos
usamos flatten<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>La función encode-bits es la siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>    (<span style="color:#66d9ef">defn </span>encode-bits [codes bytes]
</span></span><span style="display:flex;"><span>      (<span style="color:#a6e22e">flatten</span> (map codes bytes)))
</span></span></code></pre></div><p>Esa es la descripción de la compresión, les dejo el código para que
analicen la descompresión.</p>
<p>El código está acá: <a href="https://github.com/lnds/9d9l/tree/master/desafio4/clojure">https://github.com/lnds/9d9l/tree/master/desafio4/clojure</a></p>
<h2 id="way-out-of-here">Way out of here </h2>
<p>Tanto Rich Hickey como Steven Wilson son hombres de fuertes convicciones
en sus respectivos campos profesionales, uno como desarrollador de
software, el otro como artista.</p>
<p>La visión de Wilson sobre el artista (artist) se resume cuando lo
compara con el &ldquo;animador&rdquo; (entertainer):</p>
<p>«Hago una clara distinción entre estas dos. Si quieres ser un animador y
agradar a tus fanáticos, terminas dándoles lo mismo todo el tiempo. Si
eres un artista, lo haces por una necesidad más profunda dentro de ti
que es más conductiva a la experimentación e innovación.».</p>
<p>Yo creo que hay una diferencia entre el programador (que es un artista
en mi visión) y el codificador. El programador va más allá de agradar al
usuario, no le da lo que el usuario pide, sino que lo que necesita
(<a href="/blog/lnds/2013/03/23/expectativas">ya he hablado de esto</a>). En ese
sentido el codificador es como el animador que habla Wilson. Por otro
lado el artista, y el programador son innovadores y sorprenden a los
receptores de su trabajo.</p>
<p>Por otro lado, Rich Hickey en sus charlas, nos expone otra forma de
aproximarnos al arte de la programación, les recomiendo revisarlas en
sitios como InfoQ: <a href="https://www.infoq.com/profile/Rich-Hickey">https://www.infoq.com/profile/Rich-Hickey</a>.</p>
<p>Una de mis citas favoritas de Hickey es la siguiente:</p>
<blockquote>
<p>&ldquo;Simplicity is hard work. But, there&rsquo;s a huge payoff. The person who
has a genuinely simpler system - a system made out of genuinely simple
parts, is going to be able to affect the greatest change with the
least work. He&rsquo;s going to kick your ass. He&rsquo;s gonna spend more time
simplifying things up front and in the long haul he&rsquo;s gonna wipe the
plate with you because he&rsquo;ll have that ability to change things when
you&rsquo;re struggling to push elephants around.&rdquo;</p>
<p>&ndash; <em><strong>&ldquo;La simplicidad es trabajo duro.&rdquo;</strong></em></p></blockquote>
<p>Y ese es el mensaje último de este post. Los dejo con Porcupine Tree
para el cierre:</p>
<blockquote>
<p>The shutters are down and the curtains are close&gt;<br>
And I&rsquo;ve covered my tracks<br>
Disposed of the car</p></blockquote>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/SlwT7VTM_Hc?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Aunque no lo declaré antes, asumimos que los archivos son
simplemente secuencias de bytes, ignoramos su encoding.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p> Para entender un poco esto, (map codes bytes) podría generar una
salida del estilo:<br>
[[0 1 0 1 0 0] [1 0 1 0 1] [1 1 0 11] &hellip;]<br>
Al hacer flatten obtenemos:<br>
[0 1 0 1 0 0 1 0 1 0 1 1 1 0 11 &hellip;]&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Eduardo Díaz</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>2167 words</span>
    <span>13 - 17 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#porcupine-tree-y-steven-wilson">Porcupine Tree y Steven Wilson</a></li>
    <li><a href="#occams-razor">Occam&rsquo;s Razor</a></li>
    <li><a href="#simple-made-easy">Simple Made Easy</a></li>
  </ul>

  <ul>
    <li><a href="#way-out-of-here">Way out of here </a></li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/blog/lnds/2017/08/29/occams-razor/featured.jpeg">featured.jpeg</a></li></ul><h3>Related</h3>
    <ul><li><a href="/blog/lnds/2017/07/17/close-to-the-edge-down-to-the-river/">Close to the Edge, down by the river</a></li><li><a href="/blog/lnds/2017/06/10/pour-some-syntactic-sugar-on-me/">Pour Some Syntactic Sugar on Me</a></li><li><a href="/blog/lnds/2017/03/01/fake-it-till-you-make-it/">Fake it till you make it</a></li><li><a href="/blog/lnds/2016/06/21/como-obtener-el-reporte-del-clima/">Cómo obtener el reporte del clima</a></li><li><a href="/blog/lnds/2016/05/31/chubascos-de-ligera-intensidad/">Chubascos de ligera intensidad</a></li></ul></aside></div>
  </div>
</body>
</html>
