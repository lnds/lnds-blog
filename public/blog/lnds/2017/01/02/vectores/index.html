<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Vectores | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/blog/lnds/2017/01/02/vectores/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="Vectores">
  <meta property="og:description" content="Steely Dan y la perfección del sonido Durante la década de 1970 y parte de la década de 1980, Donald Fagen y Walter Becker, los fundadores de Steely Dan, aparte de ser reconocidos como grandes músicos y compositores, adquirieron fama por su excesivo perfeccionismo. Se dice, pero no he encontrado evidencia, que en uno de sus álbumes pidieron excusas por la calidad de la grabación, la que no cumplía con sus altos estándares. Esta obsesión se notó, por ejemplo, en la producción del álbum Gaucho, para el cual terminaron trabajando con 42 diferentes músicos para producir el séptimo álbum de la banda. ">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2017-01-02T08:25:11-03:00">
    <meta property="article:modified_time" content="2017-01-02T08:25:11-03:00">
    <meta property="article:tag" content="Programación">
    <meta property="article:tag" content="Lenguajes De Programación">
    <meta property="article:tag" content="Desafíos">
    <meta property="og:image" content="http://localhost:1313/blog/lnds/2017/01/02/vectores/featured.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/blog/lnds/2017/01/02/vectores/featured.png">
  <meta name="twitter:title" content="Vectores">
  <meta name="twitter:description" content="Steely Dan y la perfección del sonido Durante la década de 1970 y parte de la década de 1980, Donald Fagen y Walter Becker, los fundadores de Steely Dan, aparte de ser reconocidos como grandes músicos y compositores, adquirieron fama por su excesivo perfeccionismo. Se dice, pero no he encontrado evidencia, que en uno de sus álbumes pidieron excusas por la calidad de la grabación, la que no cumplía con sus altos estándares. Esta obsesión se notó, por ejemplo, en la producción del álbum Gaucho, para el cual terminaron trabajando con 42 diferentes músicos para producir el séptimo álbum de la banda. ">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://Newsletter.lnds.net"
      >Newsletter</a>
    </div>
    <div class="nav-item">
      <a href="/books/"
      >Books</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Vectores</h1><time class="dim" datetime="2017-01-02T08:25:11-03:00">January 2, 2017</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tag/programaci%C3%B3n/">#programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/lenguajes-de-programaci%C3%B3n/">#lenguajes de programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tag/desaf%C3%ADos/">#desafíos</a>
      </div></ol></div>
  <section class="page-section"><h1 id="steely-dan-y-la-perfección-del-sonido">Steely Dan y la perfección del sonido</h1>
<p>Durante la década de 1970 y parte de la década de 1980, Donald Fagen y
Walter Becker, los fundadores de Steely Dan, aparte de ser reconocidos
como grandes músicos y compositores, adquirieron fama por su excesivo
perfeccionismo. </p>
<p>Se dice, pero no he encontrado evidencia, que en uno de sus álbumes
pidieron excusas por la calidad de la grabación, la que no cumplía con
sus altos estándares. Esta obsesión se notó, por ejemplo, en
la producción del álbum Gaucho, para el cual terminaron trabajando con
42 diferentes músicos para producir el séptimo álbum de la banda. </p>
<p>En un momento contrataron nada menos que a Mark Knopfler, lider de
&ldquo;Dire Straits&rdquo;, para que aportara con un solo de guitarra. Fagen y
Becker quedaron impresionados con el guitarristas después de escuchar el
álbum &ldquo;Sultans of Swing&rdquo;, e invirtieron el dinero que no tenían para
contar con Knopfler en el disco, después de varias horas de grabación lo
que quedó fueron apenas unos segundos que se escuchan al inicio de la
canción &ldquo;Time Out of Mind&rdquo;.</p>
<p><img src="//d2dspjyoh5c79p.cloudfront.net/016fa77c-d142-11e6-9412-c975315961a6-aa9f18b7" alt=""></p>
<p>La perfección es inalcanzable, por supuesto, pero aún así a veces nos
obsesionamos por tratar de lograrla. Para Dijkstra, por ejemplo, la
perfección en el código estaba en la belleza y elegancia del mismo.
¿Pero qué hay del desempeño del software? Quizá el programa más elegante
no es el más eficiente en tiempo de ejecución.</p>
<p>Durante la grabación de &ldquo;Katty Lied&rdquo;<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, Fagen y Becker
experimentaron una de las mayores frustraciones de su historia. La
tecnología que eligieron para grabar, aún siendo de vanguardia, falló
causando una serie de inconvenientes técnicos, al grado que abandonaron
el proceso de edición y se rehusaron a escuchar el producto final. Fue
el guitarrista Denny Dias quien se encargó de terminar el proceso de
edición, en una heroica jornada (documentada
acá: <a href="//steelydan.com/dennys3.html">http://steelydan.com/dennys3.html</a>).</p>
<p>Uno de los problemas que enfrentaron, después de corregir el sonido de
las cintas, fue que al transferir la grabación al vinilo notaron que la
calidad se deterioraba. Otro problema es que el sonido no era el mismo y
dependía del reproductor. Así que tuvieron que volver a trabajar en la
mezcla para lograr un sonido que fuera reproducible en un &ldquo;fonógrafo
promedio&rdquo;.  Una tarea que resultó imposible, así que terminaron
conformándose con lograr que el disco fuera aceptable para la mayor
cantidad de reproductores.</p>
<p>En el desarrollo de software nos topamos con problemas similares,
nuestro programa debe ser compatible con diversos ambientes, sistemas
operativos, dispositivos, tipos de CPU, etc. Cómo lograr un desempeño
adecuado en cada uno de los ambientes es un desafío análogo al que
tuvieron que enfrentar estos ingenieros de sonido.</p>
<h1 id="optimizar-hasta-que-no-duela">Optimizar hasta que no duela</h1>
<p><em>&ldquo;La optimización prematura es la raíz de todo mal&rdquo;</em>, es la cita de
Donald Knuth más mencionada cuando hablamos de optimizar código. En
realidad la cita completa dice lo siguiente:</p>
<blockquote>
<p><em>&ldquo;No hay duda que el grial de la eficiencia lleva al abuso. Los
programadores gastan una enorme cantidad de tiempo pensando, o
preocupándose, de la velocidad de secciones no críticas de sus
programas, y esos intentos de eficiencia en realidad tienen impactos
negativos fuertes cuando consideramos la depuración y mantención.
Deberíamos olvidar pequeñas optimizaciones, digamos el 97% del tiempo:
la optimización prematura es la raíz de todo mal.</em></p></blockquote>
<blockquote>
<p>*Pero aún así no deberíamos dejar pasar nuestras oportunidades en ese
3% crítico. un buen programador no debe ser arullado por la
complacencia ante tal razonamiento, debe ser sabio para mirar
cuidadosamente al código crítico, pero sólo después que este código ha
sido identificado. A menudo es un error hacer juicios a priori sobre
las partes de un programa que son realmente críticas, puesto que la
experiencia universal de los programadores que han usado herramientes
de medición ha sido que sus intuiciones a menudo fallan.&rdquo; <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p></blockquote>
<p>Este artículo corresponde a la tercera etapa de mi desafío de aprender 9
lenguajes de programación a través de nueve problemas.</p>
<p>Si quieres saber más sobre este proyecto lee acá:
<a href="/blog/lnds/2016/01/09/esos-raros-lenguajes-nuevos">https://www.lnds.net/blog/lnds/2016/01/09/esos-raros-lenguajes-nuevos</a></p>
<p>Esta vez aproveché el problema para explorar un poco más ciertas
características de los lenguajes, tratando de optimizar las soluciones
para lograr el máximo de velocidad durante la ejecución.</p>
<h2 id="un-problema-de-la-vida-real">Un problema de la vida real</h2>
<p>Este problema en particular está basado en una situación real que se dio
en mi trabajo. Un grupo de analistas había desarrollado una serie de
macros en Excel (apoyados con algo de código VBA) para procesar un
conjunto de archivos. El problema es que esta solución tomaba varias
horas para un archivo de unas miles de lineas, y en operación real los
archivos tendrían varios millones de registros, lo que hacía inviable
procesarlos. No teníamos en ese momento capacidad para atender este
requerimiento, así que decidí crear un pequeño utilitario en C para
reemplazar las macros en Excel como solución temporal (con el tiempo, se
desarrollaron aplicaciones que reemplazaron estos procesos &ldquo;manuales&rdquo;).</p>
<p>Este ejercicio reproduce más o menos el mismo problema y su enunciado es
el siguiente:</p>
<blockquote>
<p>Se debe construir un filtro que reciba un archivo de vectores y los
consolide en un archivo de salida.</p>
<p>La invocación del programa es la siguiente:</p>
<pre><code>     $ ordenar_vector archivo_entrada archivo_salida
</code></pre>
<p>Si no se le entregan argumentos al programa este debe salir con un
mensaje de error.</p>
<p>Al finalizar debe desplegar el tiempo, en minutos y segundos, empleado
en procesar todo el archivo de entrada.</p>
<p>La entrada consiste en un archivo en que cada línea se divide en:</p>
<ul>
<li>Encabezado: 9 dígitos</li>
<li>Detalle: que consiste en 6 vectores</li>
<li>Vector: que contiene en 23 elementos que corresponden a periodos
calendario (mes de algún año)</li>
<li>Periodo: un número de 6 dígitos, puede ser 000000 o un número de
la forma AAAAMM donde AAAA es un año y MM un mes.</li>
</ul>
<p>La operación que se debe realizar es la siguiente:</p></blockquote>
<blockquote>
<p>Se deben consolidar todos los periodos de los 6 vectores en un vector
de a lo más 23 elementos.</p>
<p>Si los periodos se repiten se debe dejar sólo 1.</p>
<p>Los periodos se deben ordenar de mayor a menor.</p>
<p>La salida debe ser la siguiente:</p>
<ol>
<li>Encabezado: 9 dígitos que se copian de la entrada</li>
<li>Marca: una letra que puede tener los valores S, N ó D.</li>
<li>Vector: un vector de a lo más 23 periodos.</li>
</ol>
<p>Se debe considerar lo siguiente:</p>
<ol>
<li> Si el vector consolidado tiene más de 23 elementos se debe
colocar la marca S y el vector se debe llenar de espacios en
blanco.</li>
<li>Si el vector consolidado tiene cero elementos (porque vienen sólo
0s en los periodos) se debe colocar la marca N.</li>
</ol>
<p>Si el vector tiene menos de 24 elementos se debe colocar la marca D.</p>
<p>Hay que considerar lo siguiente:</p>
<ol>
<li> Si una linea tiene un largo distinto al esperado se debe reportar
el error indicando el número de linea (numeradas a partir de 0).</li>
<li>Si no es posible abrir un archivo se debe reportar el error.</li>
</ol></blockquote>
<p>Para efectos de referencia, incluí una solución en C que es muy similar
al programa que implementé originalmente.</p>
<p>El código se encuentra en GitHub: <a href="https://github.com/lnds/9d9l">https://github.com/lnds/9d9l</a></p>
<h2 id="buscando-la-solución-más-rápida">Buscando la solución más rápida</h2>
<p>Para efectos de prueba, ejecuté todas las soluciones usando un archivo
de un millón de lineas. Hay un script en Perl que permite generar
archivos de prueba, que están incluidos en el repositorio GitHub de este
proyecto.</p>
<p>La &ldquo;diversión&rdquo; de este desafío consistió en reducir el tiempo de
ejecución de cada solución y tratar de superar la solución en C.</p>
<p>Si compilas mi solución en C sin ningún tipo de optimización, el tiempo
de ejecución para un millón de lineas es de 8.8 segundos en mi
notebook<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. Con la opción -O3 el tiempo de ejecución se reduce a
3.54 segundos.</p>
<p>Lo sorprendente fue encontrar una solución en Go más rápida que se
ejecuta en apenas 2.92 segundos!</p>
<p>Este es el ranking medido en mi PC, para un millón de lineas:</p>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>Lenguaje</th>
          <th>Tiempo</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>Go</td>
          <td>2.92</td>
      </tr>
      <tr>
          <td>2</td>
          <td>C Opt.</td>
          <td>3.54</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Kotlin</td>
          <td>3.81</td>
      </tr>
      <tr>
          <td>4</td>
          <td>Rust</td>
          <td>3.99</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Swift</td>
          <td>4.66</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Scala</td>
          <td>6.02</td>
      </tr>
      <tr>
          <td>7</td>
          <td>Clojure</td>
          <td>7.79</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Haskell</td>
          <td>8.05</td>
      </tr>
      <tr>
          <td>9</td>
          <td>F#</td>
          <td>8.64</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Erlang</td>
          <td>49.25</td>
      </tr>
  </tbody>
</table>
<p>Este tipo de operaciones no es algo para lo que Erlang (y sus
bibliotecas estándares) están diseñado (aunque sospecho que es posible
construir una solución más rápida usando binaries, en vez de strings,
pero no conozco suficiente de Erlang para demostrarlo).</p>
<h2 id="cómo-resolver-este-problema">Cómo resolver este problema</h2>
<p>La forma general para resolver este problema se puede expresar en el
siguiente algoritmo:</p>
<pre><code> - por cada linea en el archivo de entrada:
   - si el largo de linea no es el apropiado 
        =&gt; imprimir error indicando el numero de linea
   - si el largo de linea es el que corresponde =&gt;
      - dividir la linea en 6*23 periodos (23 strings de tamaño 6)
      - descartar los periodos que sólo contengan ceros (&quot;000000&quot;)
      - descartar los periodos duplicados
      - ordenar los periodos de mayor al menor
      - Finalmente escribir en la salida lo siguiente:
         - si la cantidad de periodos que quedan es 0 colocar una N y 
           rellenar la salida con blancos
         - si la cantidad de periodos que quedan es mayor que 23 
           colocar una S y rellenar la salida con blancos
         - en cualquier otro caso colocar una D, luego concatenar los 
           periodos y rellenar con blancos
</code></pre>
<h2 id="la-solución-más-breve">La solución más breve</h2>
<p>En términos de cantidad líneas de código este es el ranking:</p>
<table>
  <thead>
      <tr>
          <th>#</th>
          <th>Lenguaje</th>
          <th>Lineas</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>F#      </td>
          <td>52</td>
      </tr>
      <tr>
          <td>2</td>
          <td>Haskell </td>
          <td>62</td>
      </tr>
      <tr>
          <td>3</td>
          <td>Kotlin  </td>
          <td>64</td>
      </tr>
      <tr>
          <td>4</td>
          <td>Clojure </td>
          <td>70</td>
      </tr>
      <tr>
          <td>5</td>
          <td>Erlang  </td>
          <td>75</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Scala   </td>
          <td>82</td>
      </tr>
      <tr>
          <td>7</td>
          <td>C       </td>
          <td>90</td>
      </tr>
      <tr>
          <td>8</td>
          <td>Rust    </td>
          <td>90</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Go      </td>
          <td>94</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Swift   </td>
          <td>129</td>
      </tr>
  </tbody>
</table>
<p>Notar que nuevamente Kotlin está en el tercer lugar.</p>
<h2 id="ordenando-los-vectores-en-c-rust-go-y-swift"><strong>Ordenando los vectores en C, Rust, Go y Swift</strong></h2>
<p>En C, Rust, Go y Swift la solución se construyó de modo similar.</p>
<h3 id="c">C</h3>
<p>En C creamos un área de trabajo la que ordenamos &ldquo;in place&rdquo; usando un
algoritmo de sort de inserción.</p>
<p>El área de trabajo es un arreglo de periodos (de ancho 6, definido en la
macro VECTOR_ELEM_SIZE).</p>
<p>El código para ordenar el vector queda así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ordena_vector</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> vector)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">char</span> vector_trabajo[VECTOR_SIZE<span style="color:#f92672">*</span>CANTIDAD_INSTITUCIONES][VECTOR_ELEM_SIZE];
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> vector;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> vend <span style="color:#f92672">=</span> vector<span style="color:#f92672">+</span>(VECTOR_SIZE<span style="color:#f92672">*</span>VECTOR_ELEM_SIZE);
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)vector_trabajo, <span style="color:#e6db74">&#39;0&#39;</span>, VECTOR_SIZE<span style="color:#f92672">*</span>CANTIDAD_INSTITUCIONES<span style="color:#f92672">*</span>VECTOR_ELEM_SIZE);   <span style="color:#75715e">// por cada elemento del vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">for</span> (p <span style="color:#f92672">=</span> vector; p <span style="color:#f92672">&lt;</span> vend <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39; &#39;</span>; p<span style="color:#f92672">+=</span> VECTOR_ELEM_SIZE) 
</span></span><span style="display:flex;"><span>       {
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// sort por insercion
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strncmp</span>(p, vector_trabajo[i], VECTOR_ELEM_SIZE) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>              ;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> n) {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strncmp</span>(p, vector_trabajo[n], VECTOR_ELEM_SIZE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">memmove</span>(vector_trabajo[n<span style="color:#f92672">++</span>], p, VECTOR_ELEM_SIZE);
</span></span><span style="display:flex;"><span>          } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strncmp</span>(p, vector_trabajo[i], VECTOR_ELEM_SIZE) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> VECTOR_SIZE<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span> i; j<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>                  <span style="color:#a6e22e">memmove</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)vector_trabajo[j], vector_trabajo[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], VECTOR_ELEM_SIZE);
</span></span><span style="display:flex;"><span>               <span style="color:#a6e22e">memmove</span>(vector_trabajo[i], p, VECTOR_ELEM_SIZE);
</span></span><span style="display:flex;"><span>               n<span style="color:#f92672">++</span>;   
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>       } <span style="color:#75715e">// for   memset(vector, &#39; &#39;, VECTOR_ELEM_SIZE*VECTOR_SIZE+1);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, p <span style="color:#f92672">=</span> vector<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>, p<span style="color:#f92672">+=</span> VECTOR_ELEM_SIZE)
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">memmove</span>(p, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)vector_trabajo[i], VECTOR_ELEM_SIZE);
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Este función retorna la cantidad de elementos que quedan en el vector.
Acá vector es el string leído desde el archivo de entrada.</p>
<p>Una optimización obvia sería usar el mismo buffer de entrada com área de
trabajo y ordenarlo. Ese es un bonito desafío en si mismo que queda
propuesto.</p>
<p>Otra cosa, este código, al momento de escribir esto, tiene algunos bugs,
te desafío a indicar cuáles son.</p>
<h3 id="rust">Rust</h3>
<p>Para la solución Rust imité lo que hace la solución en C.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>     <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ordenar_vector</span>(vector:<span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">u8</span>], result:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [<span style="color:#66d9ef">u8</span>]) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> trabajo <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span>; <span style="color:#66d9ef">TAM_VECTOR_ENTRADA</span>];
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">for</span> p <span style="color:#66d9ef">in</span> vector.chunks(<span style="color:#66d9ef">TAM_PERIODO</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> p <span style="color:#f92672">==</span> <span style="color:#66d9ef">CERO</span> { <span style="color:#66d9ef">continue</span>; }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> q <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> p <span style="color:#f92672">&lt;</span> <span style="color:#f92672">&amp;</span>trabajo[q<span style="color:#f92672">..</span>q<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>] { i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>; q <span style="color:#f92672">+=</span> <span style="color:#66d9ef">TAM_PERIODO</span>; } <span style="color:#75715e">// busca si p está en el arreglo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> p <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>trabajo[q<span style="color:#f92672">..</span>q<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>] { <span style="color:#66d9ef">continue</span>; } <span style="color:#75715e">// si ya existe lo ignora
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// inserta p en el arreglo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> n {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">let</span> q <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> <span style="color:#66d9ef">TAM_PERIODO</span>;
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">&amp;</span>trabajo[q<span style="color:#f92672">..</span>q<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>].clone_from_slice(p);
</span></span><span style="display:flex;"><span>         } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#66d9ef">ELEMENTOS_VECTOR</span>).rev() {
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">let</span> q <span style="color:#f92672">=</span> j<span style="color:#f92672">*</span><span style="color:#66d9ef">TAM_PERIODO</span>;
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>                     ptr::copy_nonoverlapping(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> trabajo[q<span style="color:#f92672">-</span><span style="color:#66d9ef">TAM_PERIODO</span>], <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> trabajo[q], <span style="color:#66d9ef">TAM_PERIODO</span>)
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">let</span> q <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span><span style="color:#66d9ef">TAM_PERIODO</span>;
</span></span><span style="display:flex;"><span>             trabajo[q<span style="color:#f92672">..</span>q<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>].clone_from_slice(p);
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// retorna el resultado
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>         result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;N&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">ELEMENTOS_VECTOR</span> {
</span></span><span style="display:flex;"><span>         result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;S&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>         result[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;D&#39;</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u8</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>n {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">let</span> p <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span><span style="color:#66d9ef">TAM_PERIODO</span>;
</span></span><span style="display:flex;"><span>             result[p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>p<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>].clone_from_slice(<span style="color:#f92672">&amp;</span>trabajo[p<span style="color:#f92672">..</span>p<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>])
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>El tipo de datos u8 corresponde a un byte sin signo. En Rust los
vectores tienen un método bastante conveniente llamado chunks(n), que
permite dividir el vector en subvectores de tamaño n. En este loop la
variable p es cada periodo del vector (uno de los chunks).</p>
<p>El equivalente a memove() en C se logra en Rust usando rangos.</p>
<p>Por ejemplo, la expresión:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>         <span style="color:#f92672">&amp;</span>trabajo[q<span style="color:#f92672">..</span>q<span style="color:#f92672">+</span><span style="color:#66d9ef">TAM_PERIODO</span>].clone_from_slice(p);
</span></span></code></pre></div><p>Es la que permite copiar en ese segmento del arreglo de trabajo desde p.</p>
<p>Hay que recordar que Rust tiene unas estrictas reglas para copiar datos
de un area de memoria a otra y las reglas de ownership obligan a
&ldquo;clonar&rdquo; bytes de un arreglo a otro[4].</p>
<p>Es por esta razón que para mover dentro de un arreglo debemos usar
código unsafe:</p>
<pre><code> unsafe {
 ptr::copy_nonoverlapping(&amp;mut trabajo[q-TAM_PERIODO], &amp;mut trabajo[q], TAM_PERIODO)
 }
</code></pre>
<p>También se podría optimizar aún más el código haciendo un sort in place
en sólo un buffer, lo que queda propuesto.</p>
<h3 id="go">Go</h3>
<p>En Go la solución es igual de sencilla y similar a las versiones en Rust
y C</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>     <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ordenar_vector</span>(<span style="color:#a6e22e">buf</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">result</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">trabajo</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">TAM_VECTOR_ENTRADA</span>, <span style="color:#a6e22e">TAM_VECTOR_ENTRADA</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">TAM_PERIODO</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#a6e22e">cero</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#e6db74">&#39;0&#39;</span> }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">TAM_VECTOR_ENTRADA</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">++</span> { <span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#e6db74">&#39;0&#39;</span> }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">p</span> &lt; <span style="color:#a6e22e">TAM_VECTOR_ENTRADA</span>; <span style="color:#a6e22e">p</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">TAM_PERIODO</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">periodo</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">p</span>:<span style="color:#a6e22e">p</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>]
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">periodo</span>, <span style="color:#a6e22e">cero</span>) { <span style="color:#66d9ef">continue</span> }
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">periodo</span>, <span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>]) &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">q</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">TAM_PERIODO</span> 
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">periodo</span>, <span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>]) { <span style="color:#66d9ef">continue</span> }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">n</span> {
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">TAM_PERIODO</span>
</span></span><span style="display:flex;"><span>                 copy(<span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>], <span style="color:#a6e22e">periodo</span>)
</span></span><span style="display:flex;"><span>             } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ELEMENTOS_VECTOR</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> &gt; <span style="color:#a6e22e">i</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">--</span> { 
</span></span><span style="display:flex;"><span>                     <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">j</span><span style="color:#f92672">*</span><span style="color:#a6e22e">TAM_PERIODO</span>
</span></span><span style="display:flex;"><span>                     copy(<span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>], <span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span><span style="color:#f92672">-</span><span style="color:#a6e22e">TAM_PERIODO</span>:<span style="color:#a6e22e">q</span>])
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">TAM_PERIODO</span>
</span></span><span style="display:flex;"><span>                 copy(<span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>], <span style="color:#a6e22e">periodo</span>)
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">result</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;N&#39;</span>
</span></span><span style="display:flex;"><span>         } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#a6e22e">ELEMENTOS_VECTOR</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">result</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;S&#39;</span>
</span></span><span style="display:flex;"><span>         } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#a6e22e">result</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;D&#39;</span>
</span></span><span style="display:flex;"><span>             copy(<span style="color:#a6e22e">result</span>[<span style="color:#ae81ff">1</span>:<span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">TAM_PERIODO</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">trabajo</span>[<span style="color:#ae81ff">0</span>:<span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">TAM_PERIODO</span>])
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div><p>Usamos rangos para operar con secciones del arreglo de entrada. Copiar
segmentos del vector al área de trabajo es bastante simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>     copy(<span style="color:#a6e22e">trabajo</span>[<span style="color:#a6e22e">q</span>:<span style="color:#a6e22e">q</span><span style="color:#f92672">+</span><span style="color:#a6e22e">TAM_PERIODO</span>], <span style="color:#a6e22e">periodo</span>)
</span></span></code></pre></div><p>Los rangos, tanto en Rust como en Go van desde el indice inicial hasta
el valor anterior del indice final, por ejemplo, vector[0..6] devuelve
6 elementos, desde el 0 al 5 inclusive.</p>
<h3 id="swift">Swift</h3>
<p>El código en Swift recibe los dos vectores que son declarados
externamente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>     <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">ordenarVector</span>(<span style="color:#66d9ef">_</span> buf: [Int8], <span style="color:#66d9ef">_</span> trabajo : <span style="color:#66d9ef">inout</span> [Int8]) -&gt; Int {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">var</span> p = posVector
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">var</span> n = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">let</span> tope = largoLinea<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&lt;</span> tope {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> buf[p..&lt;p<span style="color:#f92672">+</span>tamPeriodo] == ceroData {
</span></span><span style="display:flex;"><span>                 p <span style="color:#f92672">+=</span> tamPeriodo
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">var</span> i = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">var</span> q = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> buf[p..&lt;p<span style="color:#f92672">+</span>tamPeriodo].lexicographicallyPrecedes(trabajo[q..&lt;q<span style="color:#f92672">+</span>tamPeriodo]) {
</span></span><span style="display:flex;"><span>                 i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 q <span style="color:#f92672">+=</span> tamPeriodo
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> buf[p..&lt;p<span style="color:#f92672">+</span>tamPeriodo] == trabajo[q..&lt;q<span style="color:#f92672">+</span>tamPeriodo] {
</span></span><span style="display:flex;"><span>                 p <span style="color:#f92672">+=</span> tamPeriodo
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> i == n {
</span></span><span style="display:flex;"><span>                 q = n <span style="color:#f92672">*</span> tamPeriodo
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">for</span> k <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;tamPeriodo {
</span></span><span style="display:flex;"><span>                     trabajo[q<span style="color:#f92672">+</span>k] = buf[p<span style="color:#f92672">+</span>k]
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>             } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">var</span> j = tamVector<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&gt;</span> i {
</span></span><span style="display:flex;"><span>                     q = j <span style="color:#f92672">*</span> tamPeriodo
</span></span><span style="display:flex;"><span>                     <span style="color:#66d9ef">for</span> k <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;tamPeriodo {
</span></span><span style="display:flex;"><span>                         trabajo[q<span style="color:#f92672">+</span>k] = trabajo[q<span style="color:#f92672">-</span>tamPeriodo<span style="color:#f92672">+</span>k]
</span></span><span style="display:flex;"><span>                     }
</span></span><span style="display:flex;"><span>                     j <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>                 q = i <span style="color:#f92672">*</span> tamPeriodo
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;tamPeriodo {
</span></span><span style="display:flex;"><span>                     trabajo[q<span style="color:#f92672">+</span>j] = buf[p<span style="color:#f92672">+</span>j]
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>             n <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>             p <span style="color:#f92672">+=</span> tamPeriodo
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> n
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div><p>Swift tiene operaciones para copiar segmentos (slices) de un arreglo,
uno puede escribir lo siguiente:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>     trabajo[q..&lt;q<span style="color:#f92672">+</span>tamPeriodo] = bug[p..&lt;p<span style="color:#f92672">+</span>tamPeriodo]
</span></span></code></pre></div><p>Pero noté que el compilador genera código muy ineficiente para estas
operaciones, pues construye un objeto para cada segmento que luego es
liberado. Es por esto que opté por escribir estos loops para copiar los
elementos de un vector:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> j <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>.&lt;tamPeriodo {
</span></span><span style="display:flex;"><span>         trabajo[q<span style="color:#f92672">+</span>j] = buf[p<span style="color:#f92672">+</span>j]
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div><p>Esperemos que futuras versiones del compilador de Swift resuelvan este
problema y generen código más eficiente.</p>
<h2 id="solucionando-con-la-jvm">Solucionando con la JVM</h2>
<p>Hay tres lenguajes basados en la JVM en este desafío, Clojure, Scala y
Kotlin.</p>
<h3 id="clojure">Clojure</h3>
<p>Mi primera solución fue en Clojure, que es un lenguaje dinámico
funcional. El código para ordenar el periodo es bastante sencillo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>     (<span style="color:#66d9ef">defn </span>agregar-periodo [<span style="color:#f92672">^</span>String linea ini fin lista]
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">.regionMatches</span> linea ini ceros <span style="color:#ae81ff">0</span> tam-periodo)
</span></span><span style="display:flex;"><span>           lista 
</span></span><span style="display:flex;"><span>           (<span style="color:#a6e22e">conj!</span> lista (subs linea ini fin))))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">; lista debe ser un set</span>
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">defn </span>extraer-periodos [<span style="color:#f92672">^</span>String linea]
</span></span><span style="display:flex;"><span>         (<span style="color:#66d9ef">loop </span>[ini pos-vector fin pos-segundo-periodo lista (<span style="color:#a6e22e">transient</span> <span style="color:#f92672">#</span>{})]
</span></span><span style="display:flex;"><span>             (<span style="color:#66d9ef">if </span>(= ini tope-linea) (<span style="color:#a6e22e">persistent!</span> (<span style="color:#a6e22e">agregar-periodo</span> linea ini fin lista))
</span></span><span style="display:flex;"><span>             (<span style="color:#a6e22e">recur</span> (+ ini tam-periodo) (+ fin tam-periodo) (<span style="color:#a6e22e">agregar-periodo</span> linea ini fin lista)))))
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     (<span style="color:#66d9ef">defn </span>ordenar-periodos [<span style="color:#f92672">^</span>String linea]
</span></span><span style="display:flex;"><span>         (<span style="color:#66d9ef">let </span>[periodos (<span style="color:#a6e22e">extraer-periodos</span> linea) n (count periodos)]
</span></span><span style="display:flex;"><span>             (cond 
</span></span><span style="display:flex;"><span>                 (zero? n) (str <span style="color:#e6db74">&#34;N&#34;</span> relleno-vector)
</span></span><span style="display:flex;"><span>                 (&gt; n elementos) (str <span style="color:#e6db74">&#34;S&#34;</span> relleno-vector)
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">:else</span> (str <span style="color:#e6db74">&#34;D&#34;</span> (<span style="color:#a6e22e">s/join</span> (take elementos 
</span></span><span style="display:flex;"><span>                        (concat (sort <span style="color:#f92672">#</span>(<span style="color:#a6e22e">compare</span> <span style="color:#f92672">^</span>String %2 <span style="color:#f92672">^</span>String %1) periodos) 
</span></span><span style="display:flex;"><span>                                (repeat relleno))))))))
</span></span></code></pre></div><p>Lo primero que hay que notar es que ordenamos el vector sólo al final,
después de que hemos determinado que la cantidad de periodos es mayor
que cero y menor igual que 23.</p>
<p>La función extraer periodos va insertando cada periodo en un set, lo que
permite eliminar duplicados. Por cierto, sólo agregamos el periodo si
este es distinto a cero.</p>
<p>Notar que usamos un set creado con la función (transient), que nos
permite un mayor desempeño.</p>
<p>Pero la verdadera optimización vino cuando usé la función
(<strong>.regionMatches</strong>), esta es una función de la clase String de Java. El
uso de esta función permite evitar la creación de substrings, lo que
influye en el desempeño final de esta solución.</p>
<p>La función regionMatches() permite comparar una región del string, esto
nos permite saber si la sub sección del string es cero de manera
bastante rápida.</p>
<p>Esta función fue usada posteriormente en Kotlin y Scala.</p>
<h3 id="scala">Scala</h3>
<p>El ordenamiento de Scala usa un conjunto ordenado, con esto el programa
mantiene un arreglo sin duplicados y ordenado desde el principio.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>     <span style="color:#66d9ef">def</span> ordenarPeriodos<span style="color:#f92672">(</span>linea<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">String</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">:</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">val</span> encabezado <span style="color:#66d9ef">=</span> linea<span style="color:#f92672">.</span>slice<span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> posVector<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">val</span> myOrdering <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Ordering</span><span style="color:#f92672">.</span>fromLessThan<span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">](</span><span style="color:#66d9ef">_</span> <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">_</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">var</span> periodos <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">SortedSet</span><span style="color:#f92672">.</span>empty<span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">](</span>myOrdering<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">var</span> pos <span style="color:#66d9ef">=</span> posVector
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pos <span style="color:#f92672">&lt;</span> largoLinea<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>linea<span style="color:#f92672">.</span>regionMatches<span style="color:#f92672">(</span>pos<span style="color:#f92672">,</span> ceros<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> tamPeriodo<span style="color:#f92672">))</span> 
</span></span><span style="display:flex;"><span>             periodos <span style="color:#f92672">+=</span> linea<span style="color:#f92672">.</span>slice<span style="color:#f92672">(</span>pos<span style="color:#f92672">,</span> pos<span style="color:#f92672">+</span>tamPeriodo<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>             pos <span style="color:#f92672">+=</span> tamPeriodo
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">val</span> len <span style="color:#66d9ef">=</span> periodos<span style="color:#f92672">.</span>size
</span></span><span style="display:flex;"><span>         encabezado <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> 
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;N&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">*</span> tamRelleno<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">&gt;</span> tamVector<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;S&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">*</span> tamRelleno
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;D&#34;</span> <span style="color:#f92672">+</span> periodos<span style="color:#f92672">.</span>mkString <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">*(</span>tamRelleno<span style="color:#f92672">-</span>len<span style="color:#f92672">*</span>tamPeriodo<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Notar como usamos regionMatches() para evitar insertar los ceros.</p>
<h3 id="kotlin">Kotlin</h3>
<p>La solución en Kotlin es la más rápida en la JVM y quizás la razón sea
que el ordenamiento lo hacemos al final, esto es más rápido que la
solución en Scala, que está insertando en una estructura que se mantiene
ordenada. La optimización en Scala es obvia, y queda propuesta como
ejercicio.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>     <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">ordenarVector</span>(linea:String) : String {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">val</span> encabezado = linea.substring(<span style="color:#ae81ff">0</span>, posVector)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">val</span> periodos = HashSet&lt;String&gt;()
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> posVector until largoLinea step tamPeriodo) {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> (!linea.regionMatches(i, ceros, <span style="color:#ae81ff">0</span>, tamPeriodo, <span style="color:#66d9ef">true</span>))
</span></span><span style="display:flex;"><span>                 periodos.add(linea.substring(i, i+tamPeriodo))
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> (periodos.size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">return</span> encabezado+<span style="color:#e6db74">&#34;N&#34;</span>+ relleno
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (periodos.size &gt; tamVector)
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">return</span> encabezado+<span style="color:#e6db74">&#34;S&#34;</span>+relleno
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">return</span> encabezado+<span style="color:#e6db74">&#34;D&#34;</span>+(periodos.sortedDescending().joinToString(<span style="color:#e6db74">&#34;&#34;</span>)).padEnd(tamVector* tamPeriodo)
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>     }
</span></span></code></pre></div><h2 id="tres-lenguajes-funcionales-más">Tres lenguajes funcionales más</h2>
<p>Las soluciones que quedan están en lenguajes funcionales, Haskell, F# y
Erlang.</p>
<h2 id="haskell">Haskell</h2>
<p>La solución es Haskell debe leerse de abajo para arriba para entenderse:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     chunksOf <span style="color:#f92672">::</span> <span style="color:#66d9ef">Int64</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span>]
</span></span><span style="display:flex;"><span>     chunksOf x xs <span style="color:#f92672">=</span> unfoldr (justWhen not_null (<span style="color:#66d9ef">L</span><span style="color:#f92672">.</span>splitAt x)) xs 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     periodo_valido <span style="color:#f92672">::</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
</span></span><span style="display:flex;"><span>     periodo_valido xs <span style="color:#f92672">=</span> <span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span>any (<span style="color:#f92672">/=</span> <span style="color:#e6db74">&#39;0&#39;</span>) xs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     clasificar_resultado <span style="color:#f92672">::</span> [<span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span>]
</span></span><span style="display:flex;"><span>     clasificar_resultado xs 
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">|</span> null xs <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;N&#34;</span>]
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">|</span> (length xs) <span style="color:#f92672">&gt;</span> elementos&#39; <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;S&#34;</span>]
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;D&#34;</span> <span style="color:#66d9ef">:</span> take elementos&#39; xs
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     ordenar_periodos <span style="color:#f92672">::</span> [<span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">LB</span><span style="color:#f92672">.</span><span style="color:#66d9ef">ByteString</span>] 
</span></span><span style="display:flex;"><span>     ordenar_periodos xs <span style="color:#f92672">=</span> sortDesc <span style="color:#f92672">$</span> nub <span style="color:#f92672">$</span> (filter periodo_valido xs)
</span></span></code></pre></div><p>La llamada a estas funciones es así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     clasificar_resultado <span style="color:#f92672">$</span> ordenar_periodos <span style="color:#f92672">$</span> chunksOf tam_periodo resto
</span></span></code></pre></div><p>Lo que hacemos es dividir los periodos en segmentos de tamaño 6
(tam_periodo):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>     chunksOf tam_periodo resto
</span></span></code></pre></div><p>Luego ordenar_periodos ordena de forma descendente, eliminando
duplicados (nub), filtrando sólo los periodos válidos.</p>
<p>Una optimización obvia sería ordenar sólo en el caso &ldquo;D&rdquo;, lo que
también es un ejercicio que pueden probar ustedes.</p>
<h3 id="f">F#</h3>
<p>El ordenamiento de los periodos es bastante simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> ordenar_periodos <span style="color:#f92672">(</span>linea<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">let</span> periodos <span style="color:#f92672">=</span> separar_periodos linea <span style="color:#f92672">|&gt;</span> Seq.distinct <span style="color:#f92672">|&gt;</span> Seq.toList 
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> Seq.length periodos
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> len <span style="color:#f92672">=</span> 0 <span style="color:#66d9ef">then</span> <span style="color:#e6db74">&#34;N&#34;</span><span style="color:#f92672">.</span>PadRight<span style="color:#f92672">(</span>PAD_SIZE<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> len <span style="color:#f92672">&gt;</span> ELEMENTOS_VECTOR <span style="color:#66d9ef">then</span> <span style="color:#e6db74">&#34;S&#34;</span><span style="color:#f92672">.</span>PadRight<span style="color:#f92672">(</span>PAD_SIZE<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">else</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;D&#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>periodos <span style="color:#f92672">|&gt;</span> Seq.sortDescending <span style="color:#f92672">|&gt;</span> String.Concat<span style="color:#f92672">)).</span>PadRight<span style="color:#f92672">(</span>PAD_SIZE<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>La función separar_periodos fue programada de manera imperativa para
poder lograr un mejor performance, esto permitió reducir el tiempo
varios segundos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> separar_periodos <span style="color:#f92672">(</span>linea<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span> seq <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">let</span> mutable p <span style="color:#f92672">=</span> POS_VECTOR
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&lt;</span> LARGO_LINEA <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span> no_es_cero linea p <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">yield</span> linea<span style="color:#f92672">.</span>Substring<span style="color:#f92672">(</span>p<span style="color:#f92672">,</span> TAM_PERIODO<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>             p <span style="color:#f92672">&lt;-</span> p <span style="color:#f92672">+</span> TAM_PERIODO
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Esta implementación de F# pudo haber sido escrita de forma más
compacta, pero tuve que recurrir a varias optimizaciones usando código
más imperativo. La primera solución en F# se ejecutaba en más de 20
segundos. Con estas optimizaciones llegamos a menos de 9 segundos.</p>
<h3 id="erlang">Erlang</h3>
<p>La solución en erlang es recursiva, y usa una estructura de arreglos
ordenados. Esto fue lo más rápido que pude lograr, con tiempos menores a
50 segundos. </p>
<p>La versión inicial tomaba más de tres minutos para un archivo de un
millón de lineas, uno de los impactos más grandes fue usar archivos en
modo raw, puesto que Erlang usa otro proceso para ejecutar todo el IO a
menos que los archivos sean abiertos en modo raw. Después de eso las
mejoras fueron marginales. </p>
<p>Quizás con un equivalente a la función regionMatches de JVM esta versión
podría bajar de los 20 segundos. Sospecho que usando binaries también,
pero eso requiere conocimientos más avanzados de Erlang.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-erlang" data-lang="erlang"><span style="display:flex;"><span>     ordenar_vector(Vector) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>         Encabezado <span style="color:#f92672">=</span> substr(Vector, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">?</span>POS_VECTOR),
</span></span><span style="display:flex;"><span>         Periodos <span style="color:#f92672">=</span> separar_periodos(substr(Vector, <span style="color:#f92672">?</span>INI_VECTOR, <span style="color:#f92672">?</span>LARGO_VECTOR), new(), <span style="color:#f92672">?</span>LARGO_VECTOR),
</span></span><span style="display:flex;"><span>         Largo <span style="color:#f92672">=</span> size(Periodos),
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> Largo <span style="color:#f92672">=:=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> [Encabezado|<span style="color:#f92672">?</span>N_RELLENO];
</span></span><span style="display:flex;"><span>            Largo <span style="color:#f92672">&gt;</span> <span style="color:#f92672">?</span>ELEMENTOS_VECTOR <span style="color:#f92672">-&gt;</span> [Encabezado|<span style="color:#f92672">?</span>S_RELLENO];
</span></span><span style="display:flex;"><span>            true <span style="color:#f92672">-&gt;</span> P <span style="color:#f92672">=</span> reverse(to_list(Periodos)),
</span></span><span style="display:flex;"><span>            L <span style="color:#f92672">=</span> (<span style="color:#f92672">?</span>TAM_RELLENO<span style="color:#f92672">-</span>len(P)<span style="color:#f92672">*?</span>TAM_PERIODO) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, 
</span></span><span style="display:flex;"><span>            [Encabezado, <span style="color:#e6db74">&#34;D&#34;</span>, P, chars(<span style="color:#ae81ff">32</span>, L)]
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">end</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     separar_periodos(Linea, Periodos, <span style="color:#f92672">?</span>TAM_PERIODO) <span style="color:#f92672">-&gt;</span> 
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> Linea <span style="color:#f92672">=:=</span> <span style="color:#f92672">?</span>CEROS <span style="color:#f92672">-&gt;</span> Periodos;
</span></span><span style="display:flex;"><span>            true <span style="color:#f92672">-&gt;</span> add_element(Linea, Periodos)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">end</span>;
</span></span><span style="display:flex;"><span>     separar_periodos(Linea, Periodos, Largo) <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>         Periodo <span style="color:#f92672">=</span> substr(Linea, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">?</span>TAM_PERIODO),
</span></span><span style="display:flex;"><span>         Resto <span style="color:#f92672">=</span> substr(Linea, <span style="color:#f92672">?</span>TAM_PERIODO_MAS_1),
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> Periodo <span style="color:#f92672">=:=</span> <span style="color:#f92672">?</span>CEROS <span style="color:#f92672">-&gt;</span> separar_periodos(Resto, Periodos, Largo<span style="color:#f92672">-?</span>TAM_PERIODO);
</span></span><span style="display:flex;"><span>            true <span style="color:#f92672">-&gt;</span> separar_periodos(Resto, add_element(Periodo, Periodos), Largo<span style="color:#f92672">-?</span>TAM_PERIODO)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">end</span>.
</span></span></code></pre></div><h2 id="conclusión">Conclusión</h2>
<p>Este fue un ejercicio bastante largo, tomándome unas 48 horas de trabajo
a lo largo de cuatro meses, la razón es que me empeñé en lograr la
solución más rápida de cada lenguaje. La vara contra la que me medí fue
lograr tiempos de ejecución menores a los 10 segundos. En retrospectiva
puedo ver que es posible mejorar aún más varias de las soluciones. Ya
quiero avanzar hacia otras cosas, así que ese desafío queda para
ustedes, siempre pueden hacer un pull request con mejores soluciones o
proponer soluciones en otros lenguajes.</p>
<p>El repositorio en Github se encuentra en:
<a href="//github.com/lnds/9d9l">https://github.com/lnds/9d9l</a></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Katty Lied es el cuarto álbum de estudio de Steely Dan. Entre
otras cosas se destaca por contar con la participación por primera vez
de Michael McDonald en los coros y del gran baterista, y fundador de
Toto, Jeff porcaro, que en ese tiempo tenía apenas 20 años de edad.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Structured Programming with Goto Statements, hay una copia del
artículo acá:
<a href="http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv">http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv</a>_pl05/papers/p261-knuth.pdf&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Macbook pro 2016, Intel i7, 2.6 Ghz, 16 Gb RAM, MacOS Sierra,
Disco SSD. Las pruebas se ejecutaron sin tener ningún otro proceso
activo, desconectados de internet y con anti virus deshabilitado&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Eduardo Díaz</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>3882 words</span>
    <span>26 - 33 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#un-problema-de-la-vida-real">Un problema de la vida real</a></li>
    <li><a href="#buscando-la-solución-más-rápida">Buscando la solución más rápida</a></li>
    <li><a href="#cómo-resolver-este-problema">Cómo resolver este problema</a></li>
    <li><a href="#la-solución-más-breve">La solución más breve</a></li>
    <li><a href="#ordenando-los-vectores-en-c-rust-go-y-swift"><strong>Ordenando los vectores en C, Rust, Go y Swift</strong></a>
      <ul>
        <li><a href="#c">C</a></li>
        <li><a href="#rust">Rust</a></li>
        <li><a href="#go">Go</a></li>
        <li><a href="#swift">Swift</a></li>
      </ul>
    </li>
    <li><a href="#solucionando-con-la-jvm">Solucionando con la JVM</a>
      <ul>
        <li><a href="#clojure">Clojure</a></li>
        <li><a href="#scala">Scala</a></li>
        <li><a href="#kotlin">Kotlin</a></li>
      </ul>
    </li>
    <li><a href="#tres-lenguajes-funcionales-más">Tres lenguajes funcionales más</a></li>
    <li><a href="#haskell">Haskell</a>
      <ul>
        <li><a href="#f">F#</a></li>
        <li><a href="#erlang">Erlang</a></li>
      </ul>
    </li>
    <li><a href="#conclusión">Conclusión</a></li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/blog/lnds/2017/01/02/vectores/featured.png">featured.png</a></li></ul><h3>Related</h3>
    <ul><li><a href="/blog/lnds/2016/06/21/como-obtener-el-reporte-del-clima/">Cómo obtener el reporte del clima</a></li><li><a href="/blog/lnds/2016/05/31/chubascos-de-ligera-intensidad/">Chubascos de ligera intensidad</a></li><li><a href="/blog/lnds/2016/03/31/reporte-del-clima/">Reporte del Clima</a></li><li><a href="/blog/lnds/2016/01/09/esos-raros-lenguajes-nuevos/">Esos Raros Lenguajes Nuevos</a></li><li><a href="/blog/lnds/2016/01/13/mas-alla-del-hola-mundo/">Más allá del Hola Mundo</a></li></ul></aside></div>
  </div>
</body>
</html>
