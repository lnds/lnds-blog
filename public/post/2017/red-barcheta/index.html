<!DOCTYPE html>
<html lang="es-cl" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Red Barchetta | La Naturaleza del Software</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/post/2017/red-barcheta/">
  <meta property="og:site_name" content="La Naturaleza del Software">
  <meta property="og:title" content="Red Barchetta">
  <meta property="og:description" content="My uncle has a country place
That no one knows about
He says it used to be a farm
Before the Motor Law
Red Barchetta es la segunda canción del álbum de 1981 “Moving Pictures” de la banda canadiense Rush. Narra una historia de ciencia ficción, en un mundo futuro donde los automóviles al parecer están prohibidos. La leyenda cuenta que Neil Peart simplemente adaptó un cuento del escritor Richard S. Foster titulado “A Nice Morning Drive”, publicado en la revista Road and Track en 1973. Peart quizo contactar al autor, pero en Road and Track ya no tenían los datos de contacto de Foster, así que agregó al final de la letra en el álbum la frase: “Inspired by ‘A Nice Morning Drive’ by Richard S. Foster”.">
  <meta property="og:locale" content="es_cl">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2017-09-24T08:25:11-03:00">
    <meta property="article:modified_time" content="2017-09-24T08:25:11-03:00">
    <meta property="article:tag" content="Desafios">
    <meta property="article:tag" content="Lenguajes Nuevos">
    <meta property="article:tag" content="Lenguajes">
    <meta property="article:tag" content="Lenguajes De Programación">
    <meta property="article:tag" content="Programación">
    <meta property="article:tag" content="Rock">
    <meta property="og:image" content="http://localhost:1313/post/2017/red-barcheta/featured.jpeg">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/post/2017/red-barcheta/featured.jpeg">
  <meta name="twitter:title" content="Red Barchetta">
  <meta name="twitter:description" content="My uncle has a country place
That no one knows about
He says it used to be a farm
Before the Motor Law
Red Barchetta es la segunda canción del álbum de 1981 “Moving Pictures” de la banda canadiense Rush. Narra una historia de ciencia ficción, en un mundo futuro donde los automóviles al parecer están prohibidos. La leyenda cuenta que Neil Peart simplemente adaptó un cuento del escritor Richard S. Foster titulado “A Nice Morning Drive”, publicado en la revista Road and Track en 1973. Peart quizo contactar al autor, pero en Road and Track ya no tenían los datos de contacto de Foster, así que agregó al final de la letra en el álbum la frase: “Inspired by ‘A Nice Morning Drive’ by Richard S. Foster”.">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">La Naturaleza del Software</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a
      >Posts</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a
      >Posts</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/post/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Red Barchetta</h1><time class="dim" datetime="2017-09-24T08:25:11-03:00">September 24, 2017</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/desafios/">#desafios</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes-nuevos/">#lenguajes nuevos</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes/">#lenguajes</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/lenguajes-de-programaci%C3%B3n/">#lenguajes de programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n/">#programación</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/rock/">#rock</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/rust/">#rust</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/programaci%C3%B3n-funcional/">#programación funcional</a>
      </div></ol></div>
  <section class="page-section"><blockquote>
<p><em>My uncle has a country place</em><br>
<em>That no one knows about</em><br>
<em>He says it used to be a farm</em><br>
<em>Before the Motor Law</em></p></blockquote>
<p>Red Barchetta es la segunda canción del álbum de 1981 &ldquo;Moving
Pictures&rdquo; de la banda canadiense Rush. Narra una historia de ciencia
ficción, en un mundo futuro donde los automóviles al parecer están
prohibidos. </p>
<p>La leyenda cuenta que Neil Peart simplemente adaptó un cuento del
escritor Richard S. Foster titulado &ldquo;A Nice Morning Drive&rdquo;, publicado
en la revista <a href="http://www.roadandtrack.com/">Road and Track</a> en 1973.
Peart quizo contactar al autor, pero en Road and Track ya no tenían los
datos de contacto de Foster, así que agregó al final de la letra en el
álbum la frase: &ldquo;Inspired by &lsquo;A Nice Morning Drive&rsquo; by Richard S.
Foster&rdquo;.</p>
<p>En 1996, cuando ya había internet, Richard S. Foster encuentra una copia
de su trabajo en una página de fans de Rush. Recién ahí Foster hizo la
conexión de la canción con su historia, a pesar de haberla escuchado
muchas veces en la radio.</p>
<p>Lo curioso es que Richard S. Foster era un fan de las motocicletas, y
en una convención en 2006, un amigo le habla del libro de Neil Peart
&ldquo;Ghost Rider&rdquo;, una obra que narra el viaje curativo del baterista tras
la dramática pérdida de su esposa e hija, un recorrido de más de 150.000
kilómetros en motocicleta. Se trata de un diario de ruta, en que vemos
cómo poco a poco, kilómetro a kilómetro, Neil Peart se va curando del
dolor, la rabia y la pena de haber perdido a las mujeres más importantes
en su vida (<a href="/blog/lnds/2012/01/14/album-conceptual">de esto ya hemos hablado antes</a>).</p>
<p>Foster leyó el libro y lo encontró muy emotivo, así que en diciembre de
2006 decidió escribirle una carta a Peart, explicándole que él era el
autor de &lsquo;Nice Morning Drive&rsquo;. El escritor no tenía muchas esperanzas
de que la carta llegara a manos del famoso rockero, dada la cantidad de
correspondencia que la banda recibía, pero en enero recibió un paquete
con una copia con una dedicatoria del siguiente libro de Peart,
&ldquo;RoadShow&rdquo;, más una larga carta. </p>
<p>Aparte de que ambos compartían el amor por las motocicletas y eran
orgullosos propietarios del mismo modelo, habían muchas similaridades
entre ambas personalidades.</p>
<p>Con esto empezó una amistad por e-mail hasta que recibió una invitación
para unirse en un &ldquo;ride&rdquo; durante el tour de &ldquo;Snakes and Arrows&rdquo; de
2007. Cuando por fin se encontraron en persona Foster le entregó al
baterista una copia autografiada de Noviembre de 1973 de Road and
Track<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<figure><img src="https://d2dspjyoh5c79p.cloudfront.net/363da275-a16f-11e7-a030-2b5831f8ecb5-aa9f18b7"
    alt="Foster y Peart"><figcaption>
      <p>Foster y Peart</p>
    </figcaption>
</figure>

<h2 id="rust">Rust</h2>
<blockquote>
<p><em>Wind In my hair</em><br>
<em>Shifting and drifting</em><br>
<em>Mechanical music</em>\</p></blockquote>
<p>Esta es la cuarta parte del cuarto desafío, en esta serie sobre esos
&ldquo;raros lenguajes nuevos&rdquo;. Es el turno de Rust, el lenguaje más cercano
a la máquina de los nueve lenguajes oficiales que comprenden este
desafío.</p>
<p>Rust es un lenguaje de programación de sistemas. </p>
<p>Amo los lenguajes de programación de sistemas.</p>
<p>Cuando empecé mi carrera profesional escribía interfaces para PLCs
(Programmable Logic Controllers) y módulos para aplicaciones SCADA
(Supervisory Control An Data Acquisition). Sensores de temperatura,
contaminantes, circuitos lógicos que activaban alarmas, abrían puertas o
activaban robots ensacadores de cemento.</p>
<p>Todo lo escribíamos en C o C++. Recuerdo en particular una ocasión en
que construí un sistema de réplica de base de datos de tiempo real, un
sistema altamente concurrente en C++ y una historia de debugging que ya
conté antes: <a href="https://www.lnds.net/blog/lnds/2010/08/21/historias-de-depuracion">https://www.lnds.net/blog/lnds/2010/08/21/historias-de-depuracion</a></p>
<p>Si tuviera que hacer algo así en estos días, sin duda elegiría Rust (por
sobre Go, pero ya hablaré de Go).</p>
<p>En el capítulo 1 de &ldquo;Programming Rust&rdquo;<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>, de Jim Blandy y Jason
Orendorff, los autores explican por qué Rust:</p>
<blockquote>
<p>&ldquo;Los lenguajes de programación de sistemas han recorrido un largo
camino en los cincuenta años desde que empezamos a usar lenguajes de
alto nivel para escribir sistemas operativos, pero dos problemas en
particular han probado ser dificiles de superar:</p>
<p>- Es difícil escribir código seguro. Es especialmente dificil manejar
memoria correctamente en C y C++. Los usuarios han sufrido las
consecuencias por décadas, en la forma de agujeros de seguridad que
datan desde tan antaño como el Morris Worm de 1988.</p>
<p>- Es muy difícil escribir código multi hebras, la que es la única
forma de explotar las habilidades de las máquinas modernas. Aún los
programadores experimentados se aproximan al código multi hebra con
precaución: la concurrencia puede introducir una nueva clase de
errores y volver a los errores ordinarios más difíciles de
reproducir.&rdquo;</p></blockquote>
<p>El objetivo de Rust es ser un lenguaje seguro para administrar memoria y
la programación concurrente, con el desempeño de C y C++.</p>
<h2 id="rust-es-rush">Rust es Rush</h2>
<blockquote>
<p>Ride like the wind<br>
Straining the limits<br>
Of machine and man<br>
Laughing out loud with fear and hop</p></blockquote>
<p>Rust es un lenguaje de programación de sistemas, cercano a la máquina,
pero además es un lenguaje complejo. Complejo como <em>&ldquo;La Villa
Strangiato&rdquo;, Jacob&rsquo;s Ladder o Natural Science</em>. En otras palabras,
aproximarse a <em>&ldquo;Tom Sawyer&rdquo;</em> o <em>&ldquo;The Trees&rdquo;</em>, es un desafío mayor
para cualquier baterista aficionado. Para qué hablar de las lineas de
bajo en YYZ.</p>
<p>Aprender a programar en Rust es un desafío mayor para cualquiera, si no
han programado algo en C++ o Java, en mi opinión les va a
costar.</p>
<p>Rust es un lenguaje que es además una amalgama de varios paradigmas y
tecnologías modernas en teoría de compiladores y lenguajes. Siempre he
pensado que Rush es un gran antologista de las distintas épocas del
rock. Es decir, el Rush de los 70 está muy influenciado por The Who, Led
Zepellin, el Rush de los 80 por Yes, Genesis, y el New Wave, y así.</p>
<p>No me entiendan mal, Rush es una banda muy influyente,  pero también
selecciona lo mejor de lo que está sonando en cada época, lo adapta y en
algunos casos mejora, para entregar un producto original y potente.</p>
<p>Rust tiene las siguientes características de los lenguajes modernos:</p>
<blockquote>
<ul>
<li>No hay null en Rust \o/</li>
<li>Elementos de programación funcional (monads, como maps y
option)</li>
<li>Strong Typing y sobretodo Type Safety</li>
<li>Tipos de datos Algebraicos y Tuplas</li>
<li>Pattern matching para tipos</li>
<li>Traits y polimorfismo, pero sin herencia ni
clases</li>
<li>Las variables son inmutables por defecto</li>
<li>Tipos de punteros inteligentes</li>
<li>Modo unsafe para escribir código directo a la máquina pero
asumiendo como programadores el riesgo</li>
<li>No hay garbage collection, pero tampoco hay que preocuparse de
pedir o liberar memoria (no hay memory leaks)</li>
</ul></blockquote>
<p>Lo más interesante para mi es lo último, es un lenguaje donde no te
preocupas de pedir ni liberar memoria, lo que parece casi milagroso,
esta es una particularidad bien potente de Rust, pero tiene un precio,
una complejidad y mayor verbosidad en el código, más la necesidad de
entender bien el concepto de ownership.</p>
<p>Esto limita al lenguaje en expresividad desde la perspectiva de alguien
acostumbrado a la programación orientada al objeto, pero a cambio
obtenemos código más seguro y
robusto.</p>
<p>Cuando empiezas a aprender Rust descubres que lidias mucho tiempo con el
compilador, el que afortunadamente es muy bueno y te orienta muy bien.
Para muchos programadores, que llevan varias horas usando Rust, esta
lucha con el compilador significa que las horas de depuración se han
reducido drásticamente, y les creo (ver:
<a href="https://www.quora.com/What-do-C-C++-systems-programmers-think-of-Rust/answer/Mitchell-Nordine)">https://www.quora.com/What-do-C-C++-systems-programmers-think-of-Rust/answer/Mitchell-Nordine)</a>.</p>
<h2 id="huffman-en-rust">Huffman en Rust</h2>
<p>Recordemos que en este desafío no queremos usar las estructuras de datos
que ya tiene el lenguaje. Así que revisemos como lidiamos con el Heap
(cola de prioridad).</p>
<p>Primero declaramos nuestro TDA:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Heap</span> {
</span></span><span style="display:flex;"><span>     data: Vec<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>     last: <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En Rust los miembros de una estructura son todos privados, así que si
bien el cliente puede crear un Heap, no puede acceder a sus elementos,
para operar con nuestro TDA, usamos algunos métodos que definimos
mediante impl.</p>
<p>Fíjense que data es un vector de <code>Option\&lt;Tree\&gt;</code>, es decir, tiene
elementos que pueden o no tener un Tree.</p>
<p>Option es un tipo algebraico que en Rust es más o menos así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>     None,
</span></span><span style="display:flex;"><span>     Some(T)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Esto permite implementar la monad Option, que existe en otros lenguajes
como Scala, Swift o Haskell. Esto evita usar punteros null para indicar
la falta de un elemento en nuestro vector.</p>
<p>La implementación de los métodos de Heap se declaran acá:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Heap {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(size:<span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">Heap</span> {
</span></span><span style="display:flex;"><span>          Heap { data : <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[None;size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], last : <span style="color:#ae81ff">0</span> }
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">insert</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, elem:<span style="color:#a6e22e">Tree</span>) {
</span></span><span style="display:flex;"><span>          self.last <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>          self.data[self.last] <span style="color:#f92672">=</span> Some(elem);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> j <span style="color:#f92672">=</span> self.last;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">if</span> freq(<span style="color:#f92672">&amp;</span>self.data[j]) <span style="color:#f92672">&lt;</span> freq(<span style="color:#f92672">&amp;</span>self.data[j<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]) {
</span></span><span style="display:flex;"><span>                    self.data.swap(j, j<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>               } 
</span></span><span style="display:flex;"><span>               j <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extract</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> self.last <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>               None
</span></span><span style="display:flex;"><span>          } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">let</span> min <span style="color:#f92672">=</span> self.data[<span style="color:#ae81ff">1</span>].clone();
</span></span><span style="display:flex;"><span>               self.data[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> self.data[self.last].clone();
</span></span><span style="display:flex;"><span>               self.last <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">while</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> j <span style="color:#f92672">&lt;=</span> self.last {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> j;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> self.last <span style="color:#f92672">&amp;&amp;</span> freq(<span style="color:#f92672">&amp;</span>self.data[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&lt;</span> freq(<span style="color:#f92672">&amp;</span>self.data[k]) {
</span></span><span style="display:flex;"><span>                         k <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> freq(<span style="color:#f92672">&amp;</span>self.data[j]) <span style="color:#f92672">&lt;</span> freq(<span style="color:#f92672">&amp;</span>self.data[k]) {
</span></span><span style="display:flex;"><span>                         <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    self.data.swap(j, k);
</span></span><span style="display:flex;"><span>                    j <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>               }
</span></span><span style="display:flex;"><span>               min
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">size</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">usize</span> { self.last }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notar que tenemos un método llamado new(), que recibe un tamaño que es
el tamaño que tendrá nuestro arreglo con los datos.</p>
<p>Rust sigue el modelo funcional en el sentido que la última expresión de
una función es el valor que se retorna, veamos new de nuevo en detalle:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>         <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(size:<span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">Heap</span> {
</span></span><span style="display:flex;"><span>              Heap { data : <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[None;size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], last : <span style="color:#ae81ff">0</span> }
</span></span><span style="display:flex;"><span>         }
</span></span></code></pre></div><p>Esta función retorna una estructura de tipo Heap, donde inicializamos
cada elemento de la misma. La expresión <code>vec!\[None;size+1\]</code>, es la
invocación a una macro, que crea un vector lleno de None (elementos
vacios).</p>
<p>Así si queremos crear un Heap hacemos:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> my_heap <span style="color:#f92672">=</span> Heap::new(<span style="color:#ae81ff">100</span>);
</span></span></code></pre></div><p>Y con esto creamos un heap de tamaño 100.</p>
<p>Rust es un lenguaje orientado al objeto, pero sin clases. Los métodos
definidos en la sección Impl permiten agregar comportamiento a una
estructura, convirtiéndola formalmente en un objeto. El método new no es
un constructor, es un método estático, no hay constructores en Rust,
basta escribir un método que devuelva la estructura inicializada.</p>
<p>Noten que hay métodos que reciben self como primer parámetro, estos son
métodos propios del objeto, de este modo podemos hacer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>        my_heap.insert(tree);
</span></span></code></pre></div><p>Notarán que para ordenar los elementos del Heap usamos la función freq,
esta es su implementación:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">freq</span>(t:<span style="color:#66d9ef">&amp;</span>Option<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>t {
</span></span><span style="display:flex;"><span>          None <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>          Some(<span style="color:#66d9ef">ref</span> t) <span style="color:#f92672">=&gt;</span> freq_tree(t)
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">freq_tree</span>(t:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Tree</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>t {
</span></span><span style="display:flex;"><span>          Tree::Leaf(f, _) <span style="color:#f92672">=&gt;</span> f,
</span></span><span style="display:flex;"><span>          Tree::Node(f, _, _)<span style="color:#f92672">=&gt;</span> f
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Para entender por qué hay tantos &amp; y * en nuestro código, y por qué
aparece esas palabras raras como mut y ref en el código vamos a tener
que explicar un poco del concepto de Ownership, que es fundamental en
Rust.</p>
<h2 id="préstame-tu-auto-tio">Préstame tu auto tio</h2>
<blockquote>
<p><em>My uncle preserved for me</em><br>
<em>An old machine</em><br>
<em>For fifty-odd years</em><br>
<em>To keep it as new</em><br>
<em>Has been his dearest dream</em></p></blockquote>
<p>Rust hace dos promesas:</p>
<ol>
<li>Tú, como programador, decides el tiempo de vida de cada valor en tu
programa. Rust libera memoria y otros recursos que pertenezcan a un
valor inmediatamente en un punto bajo tu control.</li>
<li>Aún así, tu programa nunca usará un puntero a un objeto que ha sido
liberado. Esto se conoce como &ldquo;dangling pointer&rdquo; y es un error
común en C y C++. Si tienes suerte, tu programa se cae, sino tu
programa tiene un agujero de seguridad. Rust atrapa este tipo de</li>
</ol>
<p>En C y C++ se cumple la primera promesa, pero a cambio el programador es
responsable de asegurar la segunda promesa. Varios lenguajes intentan
asegurar la segunda promesa usando Garbage Collection, que se asegura de
liberar la memoria sólo cuando ningún puntero apunta al objeto. Pero
ocurre que los recolectores de basura nos sorprenden bastante seguido
con el hecho de que la memoria no es liberada cuando esperamos, y tratar
de entender por qué es bastante complicado.</p>
<p>Para garantizar estas dos promesas Rust establece 3 reglas<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>:</p>
<ol>
<li>Cada variable en Rust tiene una variable que se denomina el
propietario (owner).</li>
<li>Sólo puede haber uno propietario a la vez.</li>
<li>Cuando el propietario sale de alcance, el valor se libera.</li>
</ol>
<p>Veamos un ejemplo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;x = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span></code></pre></div><p>Esto no compila, porque x ha perdido la propiedad del string.</p>
<p>Una forma de resolver el problema es creando una copia:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x.clone();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;x = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;y = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, y);
</span></span></code></pre></div><p>Pero esto duplica memoria, entonces otra alternativa es que y sea una
referencia a x:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">ref</span> y <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;x = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;y = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, y);
</span></span></code></pre></div><p>Esto también se puede hacer así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;x = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;y = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, y);
</span></span></code></pre></div><p>Acá el operado &amp; crea una referencia a x.</p>
<p>¿Qué pasa si queremos modificar el valor de x?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>x.push_str(<span style="color:#e6db74">&#34;, world!&#34;</span>); <span style="color:#75715e">// &lt;- error x es inmutable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span></code></pre></div><p>No podemos, porque x es inmutable, entonces debemos hacer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>x.push_str(<span style="color:#e6db74">&#34;, world!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span></code></pre></div><p>¿Y qué ocurre con las referencias?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x; <span style="color:#75715e">// &lt;- error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>y.push_str(<span style="color:#e6db74">&#34;, world!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x);
</span></span></code></pre></div><p>tampoco funciona, debemos usar una referencia mutable también:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> x; 
</span></span><span style="display:flex;"><span>y.push_str(<span style="color:#e6db74">&#34;, world!&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, y);
</span></span></code></pre></div><p>Pero ojo, que no podemos hacer println!() pasando x (¿por qué?).</p>
<p>Las 3 reglas generan una serie de situaciones que son explicadas mejor
en la documentación oficial de Rust, en particular todo lo relacionado
con Ownership acá:
<a href="https://doc.rust-lang.org/book/second-edition/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/second-edition/ch04-01-what-is-ownership.html</a>.</p>
<p>Lo último que falta explicar es el *, basicamente y permite obtener el
valor apuntado por una referencia (igual que en C o C++), pero con las
consideraciones que imponen las reglas de ownership de Rust.</p>
<h2 id="tipos-de-datos-algebraicos-y-pattern-matching">Tipos de datos algebraicos y pattern matching</h2>
<p>Rust tiene una característica bien interesante, que el tipo enum, que
nos permite implementar tipos algebraicos:</p>
<p>Así nuestro tipo básico, el árbol de huffman se implementó así:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Tree</span> {
</span></span><span style="display:flex;"><span>     Leaf(<span style="color:#66d9ef">usize</span>, <span style="color:#66d9ef">u8</span>),
</span></span><span style="display:flex;"><span>     Node(<span style="color:#66d9ef">usize</span>, Box<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;</span>, Box<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>La directiva ```#[derive(Clone)]`` le indica a Rust que queremos que este
tipo implemente la operación clone() un requisito para poder usarlo en
combinación con Vec y Option.</p>
<p>En este caso nuestro tipo dice que un Tree puede ser una tupla
Leaf(usize, u8) que contiene la frecuencia y el símbolo, y Node es un
Tree que tiene la frecuencia (que es la suma de los sub árboles
izquierdo y derecho) y dos árboles.</p>
<p>El tipo Box&lt;Tree&gt; es un smart pointer, que permite definir estructuras
recursivas como Tree (en Rust el tamaño de las estructuras debe
conocerse al momento de declararlas, como estamos definiendo Tree,
usamos punteros, por eso usamos Box&lt;Tree&gt;).</p>
<p>¿Cómo usamos este tipo? Veamos un ejemplo, con la función write_tree,
que escribe el árbol en un archivo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">write_tree</span>(tree:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Tree</span>, writer:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> BitOutputStream) {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>tree {
</span></span><span style="display:flex;"><span>          Tree::Leaf(_, sym) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>               writer.write_bit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>               writer.write_byte(sym <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">u16</span>);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          Tree::Node(_, <span style="color:#66d9ef">ref</span> left, <span style="color:#66d9ef">ref</span> right) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>               writer.write_bit(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>               write_tree(left, writer);
</span></span><span style="display:flex;"><span>               write_tree(right, writer);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Acá podemos ver que recibimos una referencia a Tree como primer
argumento, por eso que usamos el * antes de usarlo en la sentencia
match.</p>
<p>En match tenemos dos caso, que sea un Tree::Leaf o un Tree::Node. Notar
que en este caso ignoramos el campo que almacena la frecuencia usando.</p>
<p>Con esto ya podemos entender la función freq():</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">freq</span>(t:<span style="color:#66d9ef">&amp;</span>Option<span style="color:#f92672">&lt;</span>Tree<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>t {
</span></span><span style="display:flex;"><span>          None <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>          Some(<span style="color:#66d9ef">ref</span> t) <span style="color:#f92672">=&gt;</span> freq_tree(t)
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">freq_tree</span>(t:<span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Tree</span>) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>t {
</span></span><span style="display:flex;"><span>          Tree::Leaf(f, _) <span style="color:#f92672">=&gt;</span> f,
</span></span><span style="display:flex;"><span>          Tree::Node(f, _, _)<span style="color:#f92672">=&gt;</span> f
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>La función freq simplemente trata el caso del Option para llamar a
<code>freq_tree()</code>, que noten sólo se ocupa del primer elemento de las tuplas
(f).</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Todo el resto del código está, como siempre, en mi repositorio GitHub:
<a href="https://github.com/lnds/9d9l/tree/master/desafio4/rust%5D">https://github.com/lnds/9d9l/tree/master/desafio4/rust]</a></p>
<h2 id="cierre">Cierre</h2>
<blockquote>
<p><em>I strip away the old debris</em><br>
<em>That hides a shining car</em><br>
<em>A brilliant Red Barchetta</em><br>
<em>From a better vanished time</em><br>
<em>We&rsquo;ll fire up the willing engine</em><br>
<em>Responding with a roar</em><br>
<em>Tires spitting gravel</em><br>
<em>I commit my weekly crime</em></p></blockquote>
<p>Rust es un lenguaje desafiante, por mucho rato traté de resolver esto
mediante un enfoque orientado al objeto tratando de usar Traits, pero no
era el camino, porque la clave es que en Rust todo el tamaño de las
estructuras debe ser conocida en tiempo de compilación, los Trait son un
contrato, no una estructura que ocupe espacio en memoria. Tampoco hay
herencia de structs, así que el camino no iba por ahí. No implica esto
que en Rust no puedes hacer orientación a objetos, lo que estoy diciendo
es que para este caso, no era la manera adecuada.</p>
<p>Queda pendiente una solución de esto usando Traits, que se puede, pero
mis conocimientos en Rust aún no están maduros para escribirla, les dejo
el código para que lo analicen y se den una idea de cómo es Rust, una
pista, se parece mucho a la solución Scala, así que eso ayuda mucho.</p>
<p>Para finalizar, escuchemos a Rush, con Red Barchetta:</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/13HoZKcJ5Hk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<p>Código fuente de los desafíos: https://github.com/lnds/9d9l</p>
<h3 id="referencias">Referencias:</h3>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The Drummer, the Private Eye, and Me (Rush Fans Take Note), <a href="http://www.bmwbmw.org/forums/viewtopic.php?f=22&amp;t=8693">http://www.bmwbmw.org/forums/viewtopic.php?f=22&amp;t=8693</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Programming Rust, O&rsquo;Reilly Media: <a href="http://shop.oreilly.com/product/0636920040385.do">http://shop.oreilly.com/product/0636920040385.do</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>The Rust Programming Language: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 </div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>2851 words</span>
    <span>17 - 22 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#rust">Rust</a></li>
    <li><a href="#rust-es-rush">Rust es Rush</a></li>
    <li><a href="#huffman-en-rust">Huffman en Rust</a></li>
    <li><a href="#préstame-tu-auto-tio">Préstame tu auto tio</a></li>
    <li><a href="#tipos-de-datos-algebraicos-y-pattern-matching">Tipos de datos algebraicos y pattern matching</a></li>
    <li><a href="#cierre">Cierre</a>
      <ul>
        <li><a href="#referencias">Referencias:</a></li>
      </ul>
    </li>
  </ul>
</nav><h3>Attachments</h3>
    <ul><li><a href="http://localhost:1313/post/2017/red-barcheta/featured.jpeg">featured.jpeg</a></li></ul><h3>Related</h3>
    <ul><li><a href="/post/2017/occams-razor/">Occam&#39;s Razor</a></li><li><a href="/post/2017/close-to-the-edge-down-to-the-river/">Close to the Edge, down by the river</a></li><li><a href="/post/2017/pour-some-syntactic-sugar-on-me/">Pour Some Syntactic Sugar on Me</a></li><li><a href="/post/2016/como-obtener-el-reporte-del-clima/">Cómo obtener el reporte del clima</a></li><li><a href="/post/2016/chubascos-de-ligera-intensidad/">Chubascos de ligera intensidad</a></li></ul></aside></div>
  </div>
</body>
</html>
